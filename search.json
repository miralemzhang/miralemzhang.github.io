[{"title":"2025 Annual -- æˆ‘åœ¨æœªæ¥ç­‰ä½ ","url":"/2025/12/24/2025/","content":"\n\nL'avenir, tu n'as pas Ã  le prÃ©voir, mais Ã  le permettre... \nL'amour, une fois qu'il a germÃ©, donne des racines qui ne finissent plus de croÃ®tre.\n\n-- Terre des hommes\n\n\nmiralem,\nhey, ä¸€å¹´å‰çš„ä½ ï¼Œå¾ˆéš¾æƒ³è±¡åˆ°å§ã€‚\ni.wow, where to start. ç¬¬ä¸€æ¬¡åœ¨åšå®¢é‡Œç”¨ä¸­æ–‡æ‰“å­—ï¼Œ\nii.â€œJâ€™ai vu la flamme de la libertÃ© faire resplendir les hommes, et la tyrannie les abrutir.â€\nè€Œé‚£åœ°æ–¹ï¼Œæˆ‘çŸ¥é“å®ƒåº”è®¸çš„ä¸èƒ½ä¹Ÿä¸ä¼šæ˜¯å±äºæˆ‘çœŸæ­£çš„å±±ï¼Œä¹Ÿä¸æ˜¯ä»–ä»¬è¶³å¤Ÿå®Œç¾ï¼Œåªæ˜¯ä»¿ä½›ï¼Œä»æ–‡æ˜çš„è§†è§’çœ‹ï¼Œä¼¼ä¹ä»…ä»…å› ä¸ºæ›´ç†Ÿæ‚‰ä»–ä»¬çœ¼ä¸­æ´‹æº¢çš„å¿«ä¹ï¼Œå¿ƒåº•æµæ·Œçš„è‡ªç”±ï¼Œä½†å¥½åƒè¿™äº›ä¹Ÿè¶³å¤Ÿäº†ã€‚ä½ é‡è¿‡å¤ªå¤šåŒªå¤·æ‰€æ€ï¼Œè§è¿‡å¤ªå¤šè’è°¬è‡³æï¼Œå¯ä½ è¿˜æ˜¯é€‰æ‹©å»ç›¸ä¿¡ï¼Œå»æ‹¥æŠ±ï¼Œå»å‹‡æ•¢ã€‚\nå› ä¸ºä½ åœ¨å¥½å¤šå¹´å‰é‚£äº›é—·çƒ­çš„åˆåé‡Œæ‡µå›°åœ°å­¦è¯»çš„è¯­æ³•ä¹¦çœŸæ˜¯å¯¹çš„ï¼Œä¸€ä¸ªäººåªæœ‰å…ˆè€•ç§æ‰èƒ½æ”¶è·ï¼Œå…ˆè¿›è¡Œæ‰ä¼šå®Œæˆï¼›å…ˆç¦»å¼€ï¼Œæ‰æœ‰å½’æ¥ã€‚\næ€»ä¼šæ¢¦æƒ³äººäººéƒ½å¯ä»¥åšä¸€ä¸ªæœ‰å°Šä¸¥çš„äººï¼Œ\näººäººèƒ½ä»¥æˆ‘ç¬”å†™æˆ‘ä¿¡ã€æˆ‘å£è¯´æˆ‘å£°ã€‚\næ‰€ä»¥ï¼Œè¿™å¹´ä½ ä¼šå»æ„Ÿæ©\nåšäº†å¯èƒ½æ˜¯äººç”Ÿé‡Œæœ€ç–¯ç‹‚çš„å†³å®šï¼Œ\nè¿˜æœ‰ä¸€è·¯éƒ½èƒ½å¸®åŠ©æˆ‘ã€ç›¸ä¿¡æˆ‘ã€é¼“åŠ±æˆ‘çš„ä½ ä»¬ã€‚å¥½å¸Œæœ›æ²¡æœ‰è¾œè´Ÿå¤ªå¤šã€‚\niii. Euphoriaå’ŒZJU-Chinaè¿™åº§æˆ‘æ°¸è¿œçš„å®¶ã€‚å†¬å¤æ˜¥ç§‹ï¼Œ\nå·´é»çš„æœˆå¤œã€é‡Œæ˜‚çš„æ™¨å…‰ï¼Œ   å¤šå¹¸è¿æˆ‘ä»¬èƒ½ä¸€èµ·å¥”èµ´ã€‚åˆ†æ‹…å¯’æ½®ã€é£é›·ã€éœ¹é›³ï¼›å…±äº«é›¾éœ­ã€æµå²šã€è™¹éœ“ã€‚\nè®©æˆ‘ç›¸ä¿¡\né‡è¦çš„ä¸æ˜¯ä¸–äº‹æœ‰æ— å¦‚æœï¼Œè€Œæ˜¯ç„¶åéª„å‚²åœ°ç‡ƒèµ·æ¯ä¸€åˆ»çœ¼å‰å¼•ç€æˆ‘è·‘ï¼Œå¤©ç©ºæ²¡æœ‰æé™\niv. æœªæ¥æ­Œå½“ä½ èµ°åˆ°å±±å¡ä¸­æ®µçš„æ—¶å€™ï¼Œçœ‹ä¸åˆ°å±±é¡¶çš„é£æ™¯ï¼Œä½ åªèƒ½çœ‹åˆ°è„šä¸‹çš„è·¯ï¼Œä½ åªèƒ½çœ‹åˆ°èº«è¾¹è‡ªå·±çš„å½±å­ï¼Œæˆ–è®¸å°±æ˜¯æœ€æƒ³æ”¾å¼ƒçš„æ—¶å€™ï¼Œå› ä¸ºä½ åœ¨çŠ¹è±«åº”è¯¥è¦å›å¤´ï¼Œè¿˜æ˜¯è¦ç»§ç»­å‘ä¸Šè¡Œã€‚\nä½ çœ‹ï¼Œæˆ‘è¿˜æ˜¯è¿™æ ·ï¼Œä¸€æ•´å¹´éƒ½è¿˜åœ¨æ‰¾ç€è‡ªå·±åˆ°åº•æƒ³è¦ä»€ä¹ˆã€‚æˆ‘ä¼šè¯´å‡ºå£æˆ‘å¾ˆç—›è‹¦ï¼Œå› ä¸ºæˆ‘çŸ¥é“ç°åœ¨æˆ‘æ‰€æœ‰æ‰€åœ¨è¿™äº›æ ¹æœ¬è¿œè¿œä¸å¤Ÿæˆ‘æ‰€æƒ³è¦çš„ï¼Œæœ‰äº›äº‹æƒ…ä¹Ÿä¸æ˜¯é ç€é•¿å¤§å°±èƒ½æœ‰ç­”æ¡ˆã€‚åŒ—æ–¹çŒç€åˆºéª¨çš„é£ï¼Œæ­å·æ ¹æœ¬å°±ä¸æ˜¯äººä½çš„åœ°æ–¹æ²¡æœ‰â€œè‡ªä¸»çš„æ¸©æš–â€ï¼Œ   ï¼Œèº«åæ˜¯ç´§è¿½ä¸èˆçš„   ï¼Œæˆ‘å´å¾®ç¬‘ç€æƒ³åˆ°äº†\nä½†æˆ‘ä¹Ÿå¾ˆå¿«ä¹ï¼Œå› ä¸ºæˆ‘çŸ¥é“\nä½ çœ‹ï¼Œé‚£äº›ä½ åŸæœ¬æ²¡æ³•æƒ³è±¡çš„æœºä¼šã€é‚£äº›ä½ å·®ç‚¹è®¤å®šå°±æ“¦èº«è€Œè¿‡çš„æ¢¦æƒ³ï¼Œç”šè‡³é‚£ä¸ªä½ ä»¥ä¸ºé¥ä¸å¯åŠçš„27fallï¼Œä¸æ˜¯éƒ½ç«Ÿè¿‘åœ¨çœ¼å‰äº†å—ã€‚â€œé‚£ä¹ˆï¼Œâ€æˆ‘æ€»è®°å¾—ä½ åœ¨åˆä¸­å°±å¾ˆå–œæ¬¢çš„è¿™äº›è¯ï¼Œå°±å¥½åƒä½ ä¼šåœ¨é‚£æ™šä¸‹ç¬”æ—¶å°±æƒ³åˆ°å’Œæœªæ¥çš„æˆ‘è¯´ï¼Œâ€œé‚£ä¹ˆï¼Œä»æ˜¯è¦å»åšä½ è§‰å¾—å¯¹çš„äº‹æƒ…ï¼Œå»æ•¢çˆ±ï¼Œå»æ•¢æ¨ï¼Œæ•¢è¯´ï¼Œæ•¢åšï¼Œæ•¢è¿½æ±‚â€¦â€¦â€â€œåˆ«å»å®³æ€•åˆ¹é‚£ï¼Œé‚£äº›äººåªèƒ½ä¸€è¾ˆå­å¾…ç€è¿™é‡Œè€Œå·²â€¦â€¦ä½ ä»¬è¯¥æœ‰â€â€œè¿™äº›ï¼Œæˆ‘æ€•çœ‹ä¸åˆ°çš„ï¼Œä½†æˆ‘çŸ¥é“æ€»æœ‰å¤©ä½ æœ‰æ–°çš„æ—…ç¨‹ï¼Œæ‰€ä»¥åˆ«ç•™é—æ†¾å§ï¼â€¦â€¦å°†æ¥çš„ä½ ï¼Œä¸€å®šä¸€å®šå¯ä»¥çœ‹å¾—åˆ°ã€‚â€\næˆ‘æ›´å¹¸è¿ï¼Œ\næˆ‘ä¸å®³æ€•ã€‚\næˆ‘ç›¸ä¿¡çš„ï¼Œå†é€‰æ‹©ï¼Œä½ è¿˜æ˜¯ä¼šç»§ç»­å°±å»å‘ä¸Šè¡Œï¼Œä½ ä»æ¥ä»æ¥ä¸ä¼šå…è®¸è‡ªå·±å°±é‚£æ ·æŠŠè‡ªå·±ç»™æä¸¢ã€‚\næˆ‘ç°åœ¨å°±é€‰æ‹©ç»§ç»­å‘ä¸Šè¡Œã€‚\nv. ã€Œç¥ä½ åœ¨äº‚æµä¸‹å¹³å®‰ã€å°è±¡é‡Œï¼Œå°æ—¶å€™ï¼Œæ¯å¹´åœ£è¯èŠ‚ï¼Œ   ï¼Œåæ¥â€”â€”å¦‚æœé‚£äº›  è¿˜å¯ä»¥è¢«åŸè°…è€Œæ‹¼å‡‘æˆäº›â€œåæ¥â€çš„è¯â€”â€”\nä¸€å¹´å¹´ï¼Œè¿™ç§è¿‘ä¹é›†ä½“æ— æ„è¯†çš„çŠ¶æ€è¿˜æ˜¯å¤§å£°é¼“å¹æˆ‘ä»¬ä»ç„¶è¯¥æŠµåˆ¶çš„æ‰€è°“é›†ä½“ä¼¦ç†ï¼Œä½†æ˜¯æˆ‘ä»¬è‡ªå·±å´ä¸çŸ¥ä¸è§‰æ…¢æ…¢åœ°è¢«æœç€è¿™ç§ä¼¦ç†å‰è¿›ï¼Œå› ä¸ºæˆ‘ä»¬â€”â€”ä¸çŸ¥ä¸è§‰â€”â€”å¿˜è®°äº†äººï¼Œäººæ˜¯å”¯ä¸€èƒ½è§£é‡Šè¿™ç§æ‹’ç»çš„ç†ç”±ã€‚æ²‰é»˜æ¯”è’å™ªæ›´åŠ å¯æ€•ï¼Œéšæ³¢é€æµçš„åŒåŒ–æ— å¤„ä¸åœ¨ï¼Œä¸èƒ½ä¸å‘é†’å•Šï¼\näºæ˜¯ï¼Œä¹Ÿä¸€å¹´å¹´ï¼Œä½ è¿˜æ˜¯     ï¼Œæˆ‘çœ‹åˆ°äº†ï¼Œé‚£äº›     éƒ½çœ‹è§äº†ã€‚å¦‚æœæˆ‘åœ¨é»æ˜å‡ºå‘ï¼Œé‚£ä¹ˆæˆ‘åº”è¯¥çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘å¦‚ä»Šè¿˜åœ¨åŠªåŠ›ï¼Œè®°ä½æˆ‘æ‰€çœ‹åˆ°çš„ã€‚æˆ‘éœ€è¦ä¸€ä¸ªç®€å•çš„ä¿¡æ¡æ¥æé†’è‡ªå·±ã€‚æˆ‘åº”è¯¥ä¸ºäººè¶…è¿‡ä¸ªä½“çš„é¦–è¦åœ°ä½è€Œå¥‹æ–—ï¼Œå°±åƒæ™®éæ€§å§‹ç»ˆè¯¥æ’åœ¨ç‰¹æ®Šæ€§çš„å‰é¢ã€‚æˆ‘ç›¸ä¿¡å¯¹æ™®éæ€§çš„æ¨å´‡ã€æ ‡æ¦œï¼Œå¹¶å°†æ‰€æœ‰ç‰¹å®šçš„è´¢å¯Œä¸æ™ºæ…§é›†åˆåœ¨ä¸€èµ·ï¼Œè€Œä¸”å®ƒæ˜¯å”¯ä¸€çœŸæ­£çš„ç§©åºï¼ŒåŒæ—¶ä¹Ÿæ˜¯ç”Ÿå‘½çš„ç§©åºã€‚ä½ çœ‹ï¼Œå³ä½¿æ ‘ä¹Ÿæ˜¯ç§©åºçš„ä¸€éƒ¨åˆ†ï¼Œå°½ç®¡å®ƒçš„æ ¹å’Œææ˜¯ä¸åŒçš„ã€‚å› è€Œæˆ‘ç›¸ä¿¡å¯¹æŸç§æƒåŠ›æˆ–åœ°ä½ç‰¹æ®Šæ€§çš„æ¨å´‡åªä¼šå¸¦æ¥å‹è¿«ï¼Œå› ä¸ºå®ƒæ˜¯ä¼å›¾å»ºç«‹åœ¨ä»¥ç›¸ä¼¼æ€§ä¸ºåŸºç¡€çš„ç§©åºä¹‹ä¸Šçš„ä¸“åˆ¶ï¼Œæ˜¯æ‰€æœ‰æš´æ”¿çš„é›å½¢ã€‚å®ƒå°†æœ¬è´¨çš„ç»Ÿä¸€å’Œéƒ¨åˆ†çš„è®¤åŒæ··æ·†ã€‚å› æ­¤æˆ‘åº”è¯¥åå¯¹é‚£äº›æƒ³è¦å°†ç‹¬è£çš„ç¤¾ä¼šæ–¹å¼å¼ºåŠ äºå…¶å®ƒç¤¾ä¼šæ–¹å¼ï¼Œå°†ç‹¬ç‰¹çš„â€œäººâ€å¼ºåŠ äºå…¶ä»–äººï¼Œå°†æŸä¸ªç‰¹å®šçš„å›½æ—å¼ºå‡Œé©¾äºå…¶ä»–çš„å›½æ—ï¼Œå°†ä¸€ç§ç‹¬ç‰¹çš„æ€ç»´æ„è¯†å¼ºåŠ äºå…¶ä»–çš„æ€ç»´æ„è¯†çš„äººã€‚æˆ‘è¯¥ç›¸ä¿¡å¼ºè°ƒäººçš„é¦–è¦åœ°ä½æ˜¯å”¯ä¸€æœ‰æ„ä¹‰çš„å¹³ç­‰å’Œè‡ªç”±çš„åŸºç¡€ï¼Œæˆ‘ä¹Ÿä¼šç›¸ä¿¡è‡ªç”±æ˜¯èƒ½æŠ•å½±åœ¨æœªæ¥é‡Œçš„æ‰€æœ‰äººå¾—ä»¥è¿½æ±‚å‘ä¸Šçš„è‡ªç”±ã€‚å¹³ç­‰ä¸æ˜¯è®¤åŒï¼Œè‡ªç”±ä¹Ÿä¸ä¼šæ˜¯ä¸ªäººå’Œäººçš„å¯¹æŠ—çš„æ”¾å¤§ã€‚æˆ‘åº”è¯¥è®°ä½åå¯¹ä»»ä½•æƒ³è¦å€Ÿç€è™šä¼ªä»¥å¥´å½¹æ— è®ºæ˜¯ä¸ªäººè¿˜æ˜¯ç”±ä¸ªäººç»„æˆçš„é›†ä½“çš„è‡ªç”±çš„äººã€‚æˆ‘ç›¸ä¿¡çœŸæ­£çš„æ–‡æ˜å°†æŠŠäººä¸ºè¿™è€Œåšå‡ºçš„ç‰ºç‰²ä»¥å‘½åçš„è‡ªç”±ï¼Œå¹¶ä½œä¸ºå®ƒå”¯ä¸€å¾—ç»Ÿæ²»çš„åŸºç¡€ã€‚è‡ªç”±æ˜¯ç»™äººçš„ç¬¬ä¸€ä¸ªç¤¼ç‰©ï¼Œæ˜¯è¶…è¶Šäº†ä¸ªäººçš„å¹³åº¸çš„ï¼šå®ƒåˆ›é€ äº†äººã€‚æˆ‘å°†åå¯¹ä»»ä½•å£°ç§°æˆ‘çš„è‡ªç”±æ˜¯ç»™å¹³åº¸è‡´æ•¬ï¼Œå¦å®šâ€œäººâ€ï¼Œå¹¶å°†ä¸ªäººæ¡æ¢äºâ€œä¸»ä¹‰â€ä¹‹å†…ã€å›šç¦åœ¨å¹³åº¸ä¹‹ä¸­çš„äººã€‚ä¹±æµä¹‹ä¸­ï¼Œæˆ‘åº”è¯¥ä¸ºäº†äººè€Œæˆ˜æ–—ï¼Œè·Ÿä»–çš„æ•Œäººæˆ˜æ–—ï¼ŒåŒæ ·ä¹ŸåŒæˆ‘è‡ªå·±æˆ˜æ–—ã€‚\nå¤šè°¢ä½ è‡ªå·±ï¼Œ  æˆ‘ä»¬æ€»èƒ½\néª„å‚²åšå¤§å†™çš„äººã€‚\nâ€œä¸ºè‡ªç”±çš„ç‰ºç‰²ç¥ç¦ï¼Œæ˜¯æ–‡æ˜åŠ è¯¸æ¯ä¸ªæˆ‘ä»¬çš„å‡†åˆ™ã€‚â€ä»æ¥ä¸å¿…å¤©æ°”å¤šæ™´æœ—ï¼Œå·¨åŒ çš„æ‰‹ä¸æ€•éª¯é«’.you can hear me,æ˜å¹´è§ æœªæ¥è§.å±±é¡¶è§ï¼\n\n\nsincerely,\n\n\n\nmlmzzzooo\n31/12/2025\n\n\n\n\n\n\n\n\n","categories":["Thoughts"],"tags":["Annual Review"]},{"title":"LeetCode 2749 - Minimum Operations to Make Integer Zero","url":"/2025/09/05/LeetCode-2749-Solution-Minimum-Operations-to-Make-Integer-Zero/","content":"Problem DescriptionYou are given two integers num1 and num2. In one operation, you can choose integer i and subtract 2^i + num2 from num1.\nReturn the minimum number of operations to make num1 equal to 0. If it is impossible to make num1 equal to 0, return -1.\nExamplesExample 1:\nInput: num1 = 3, num2 = -2Output: 3Explanation: We can apply the following operations:- Operation 1: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 3 - 2 = 1.- Operation 2: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 1 - 2 = -1.- Operation 3: i = 0, subtract 2^0 + (-2) = 1 - 2 = -1. Now num1 = -1 - (-1) = 0.\n\nExample 2:\nInput: num1 = 5, num2 = 7Output: -1Explanation: It is impossible to make num1 equal to 0.\n\nMy Unique ApproachInstead of the traditional mathematical modeling approach, I developed an iterative simulation method that directly mimics the operation process:\nKey InsightThe core idea is to simulate the process step by step:\n\nFor each potential number of operations k, subtract num2 from num1 \nCheck if the remaining value can be represented as a sum of exactly k powers of 2\nUse binary representation to count the minimum number of powers of 2 needed\n\nAlgorithm Logic\nEarly termination: If num2 &gt;= num1, return -1 (impossible case)\nIterative checking: For each k starting from 1:\nCalculate current = num1 - k * num2\nCount the number of 1â€™s in binary representation of current\nIf k &gt;= count_of_ones, we can potentially use k operations\n\n\nValidation: Ensure the solution is mathematically valid\n\nMy SolutionPython Implementationclass Solution(object):    def makeTheIntegerZero(self, num1, num2):        &quot;&quot;&quot;        :type num1: int        :type num2: int        :rtype: int        &quot;&quot;&quot;        # Early termination: if num2 &gt;= num1, impossible to reach 0        if num2 &gt;= num1:            return -1        else:            k = 1            ini = num1  # Store original num1 for validation                        while True:                # Simulate subtracting num2 for k operations                num1 -= num2                                # Convert to binary and count 1&#x27;s                bin1 = bin(num1)[2:]                count1 = bin1.count(&#x27;1&#x27;)                                # Check if we can use k operations                if k &gt;= count1:                    # Validation checks                    if ini &gt; k * num2:                        if ini - k * num2 &lt; k:                            return -1                        return k                    else:                        return -1                else:                    # Need more operations                    k += 1                    bin1 = 0                    count1 = 0\n\nAlgorithm BreakdownLet me explain each part of my unique approach:\nStep 1: Early Terminationif num2 &gt;= num1:    return -1\nIf num2 is greater than or equal to num1, itâ€™s impossible to make num1 zero because each operation adds at least num2 to the subtraction.\nStep 2: Iterative Simulationk = 1ini = num1  # Store original valuewhile True:    num1 -= num2  # Simulate the num2 part of each operation\nInstead of calculating target = num1 - k * num2 directly, I simulate the process by subtracting num2 in each iteration.\nStep 3: Binary Analysisbin1 = bin(num1)[2:]count1 = bin1.count(&#x27;1&#x27;)\nFor the current value, count how many 1â€™s are in its binary representation. This tells us the minimum number of powers of 2 needed.\nStep 4: Feasibility Checkif k &gt;= count1:    # We have enough operations to represent the number    if ini &gt; k * num2:        if ini - k * num2 &lt; k:            return -1        return k\nThe key insight: if we have k operations and only need count1 powers of 2, we can use the extra operations by â€œsplittingâ€ larger powers of 2.\nComplexity Analysis\nTime Complexity: O(log(num1)), as we iterate at most log(num1) times\nSpace Complexity: O(1), using only constant extra space\n\nWhy This Approach WorksThe Mathematical FoundationMy iterative approach is essentially equivalent to the mathematical formula:\nnum1 - kÃ—num2 = 2^iâ‚ + 2^iâ‚‚ + ... + 2^iâ‚–\n\nBut instead of calculating num1 - kÃ—num2 directly, I simulate it step by step:\n\nStart with k = 1\nSubtract num2 from num1 (simulating one operation)\nCheck if the result can be represented with k powers of 2\nIf not, increment k and repeat\n\nValidation Logic ExplainedThe nested conditions in my code serve important purposes:\nif ini &gt; k * num2:  # Ensure we haven&#x27;t subtracted too much    if ini - k * num2 &lt; k:  # Ensure target &gt;= k (necessary condition)        return -1    return k\n\nThis ensures that:\n\nThe total subtraction k * num2 doesnâ€™t exceed the original num1\nThe remaining value ini - k * num2 is at least k (since each power of 2 is at least 1)\n\nTest Cases WalkthroughLetâ€™s trace through some examples using my approach:\nExample 1: num1 &#x3D; 11, num2 &#x3D; 1Initial: num1 = 11, num2 = 1, ini = 11k = 1:- num1 = 11 - 1 = 10- bin(10) = &quot;1010&quot;, count = 2- k (1) &lt; count (2), so increment kk = 2:- num1 = 10 - 1 = 9  - bin(9) = &quot;1001&quot;, count = 2- k (2) &gt;= count (2) âœ“- ini (11) &gt; k*num2 (2) âœ“- ini - k*num2 = 9 &gt;= k (2) âœ“- Return 2\n\nExample 2: num1 &#x3D; 5, num2 &#x3D; 7Initial: num1 = 5, num2 = 7Early termination: num2 (7) &gt;= num1 (5)Return -1\n\n\nConclusionThis iterative simulation approach provides a unique perspective on solving LeetCode 2749. While the mathematical modeling approach is more direct, my method offers better intuition about whatâ€™s actually happening in each operation.\nThe key insight is that we can separate the problem into:\n\nThe num2 component (handled by iteration)\nThe powers of 2 component (handled by binary analysis)\n\nThis separation makes the solution both understandable and efficient.\n\nTutorial texts partly co-generated by Claude-4-Sonnet.\nHope this analysis helps you understand my unique approach to LeetCode 2749! Feel free to discuss any questions in the comments.\nHappy Coding! ğŸš€\n","categories":["Coding"],"tags":["LeetCode"]},{"title":"LeetCode 3363 - Find the Maximum Number of Fruits Collected","url":"/2025/11/07/LeetCode-3363-Find-Maximum-Number-of-Fruits-Collected/","content":"Problem DescriptionThere is a game dungeon comprised of n x n rooms arranged in a grid.\nYou are given a 2D array fruits of size n x n, where fruits[i][j] represents the number of fruits in the room at position (i, j). Three children will play in the game dungeon, with initial positions at the corner rooms (0, 0), (0, n - 1), and (n - 1, 0).\nThe children will make exactly n - 1 moves according to the following rules to reach the room (n - 1, n - 1):\n\nThe child starting from (0, 0) must move from their current room (i, j) to one of the rooms (i + 1, j + 1), (i + 1, j), or (i, j + 1) if the target room exists.\nThe child starting from (0, n - 1) must move from their current room (i, j) to one of the rooms (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1) if the target room exists.\nThe child starting from (n - 1, 0) must move from their current room (i, j) to one of the rooms (i - 1, j + 1), (i, j + 1), or (i + 1, j + 1) if the target room exists.\n\nWhen a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave.\nReturn the maximum number of fruits the children can collect from the dungeon.\nExamplesExample 1:\nInput: fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]Output: 100Explanation: - Child 1 (from (0,0)): (0,0) â†’ (1,1) â†’ (2,2) â†’ (3,3)- Child 2 (from (0,3)): (0,3) â†’ (1,3) â†’ (2,3) â†’ (3,3)- Child 3 (from (3,0)): (3,0) â†’ (3,1) â†’ (3,2) â†’ (3,3)\n\nExample 2:\nInput: fruits = [[1,1],[1,1]]Output: 4Explanation: All children end up at (1,1) collecting all fruits.\n\n\nIntuitionWhen I first encountered this problem, my intuition was that this is a multi-path dynamic programming problem. Three children start from different positions simultaneously and must reach the same destination (n-1, n-1) in exactly n-1 steps, with the constraint that when multiple children enter the same room, only one can collect the fruits.\nThis reminded me of a variant of the classic â€œCherry Pickupâ€ problem, but with three paths instead of two, which significantly increases the complexity. The key insight is that we need to simultaneously track the position states of all three children and correctly handle fruit collection in overlapping rooms.\n\nApproachI adopted a 4-dimensional dynamic programming approach:\nState Definitiondp(step, pos_1, pos_2, pos_3) represents the maximum number of fruits that can be collected when the three children are at positions pos_1, pos_2, pos_3 respectively at step step.\nMovement RulesEach child has different movement constraints:\n\nChild 1 (starting from (0,0)): can move right (i,j+1), down (i+1,j), or diagonally down-right (i+1,j+1)\nChild 2 (starting from (0,n-1)): can move down-left (i+1,j-1), down (i+1,j), or down-right (i+1,j+1)\nChild 3 (starting from (n-1,0)): can move up-right (i-1,j+1), right (i,j+1), or down-right (i+1,j+1)\n\nState TransitionFor each state (step, pos_1, pos_2, pos_3):\n\nCalculate current reward: Sum up fruits at the three childrenâ€™s current positions, counting overlapping positions only once.\nTry all movement combinations: Each child chooses their next position according to their movement rules.\nRecursive solution: Recursively calculate the maximum future reward for each movement combination.\nTake maximum: Choose the maximum value among all possible combinations.\n\nBase CaseWhen step = n-1, check if all three children have reached the target position (n-1, n-1):\n\nIf all reached: return the fruit count at that position (can only be collected once).\nOtherwise: return -âˆ to indicate an invalid state.\n\nMemoization OptimizationUse a dictionary memo to cache computed states and avoid redundant calculations.\ndef dp(step, pos1, pos2, pos3):    # Check cache    if (step, pos1, pos2, pos3) in memo:        return memo[(step, pos1, pos2, pos3)]        # Base case    if step == n - 1:        # Check if all reached target position        ...            # Calculate current reward + recursively solve future reward    ...    # Cache result and return\n\n\nKey Insight: Path DecompositionA crucial observation simplifies this problem dramatically:\n\nChild 1 is locked to the diagonal: Due to movement constraints and the requirement to reach (n-1, n-1) in exactly n-1 steps, Child 1 must follow the main diagonal path (0,0) â†’ (1,1) â†’ ... â†’ (n-1,n-1).\n\nChild 2 stays above the diagonal: Starting at (0, n-1) and moving downward, Child 2â€™s valid positions satisfy j â‰¥ i.\n\nChild 3 stays below the diagonal: Starting at (n-1, 0) and moving rightward, Child 3â€™s valid positions satisfy i â‰¥ j.\n\n\nThis means the three paths naturally donâ€™t overlap (except at the destination), allowing us to solve three independent subproblems!\n\nMy SolutionPython Implementationclass Solution:    def maxCollectedFruits(self, fruits):        n = len(fruits)                # Child 1: Must follow the diagonal path        child1_fruits = sum(fruits[i][i] for i in range(n))                def solve_child2():            # DP for child starting from (0, n-1)            dp = [[-1] * n for _ in range(n)]            dp[n-1][n-1] = 0  # Base case: destination reached                        # Fill DP table from bottom to top            for i in range(n-2, -1, -1):                for j in range(n):                    if j &lt; i:  # Invalid: must stay above/on diagonal                        continue                                        max_val = -1                    # Try all three moves: down-left, down, down-right                    for dj in [-1, 0, 1]:                        ni, nj = i + 1, j + dj                        if 0 &lt;= ni &lt; n and 0 &lt;= nj &lt; n and dp[ni][nj] != -1:                            # Don&#x27;t count diagonal cells (Child 1 collects them)                            curr_fruit = 0 if (i == j) else fruits[i][j]                            max_val = max(max_val, curr_fruit + dp[ni][nj])                                        dp[i][j] = max_val                        return dp[0][n-1] if dp[0][n-1] != -1 else 0                def solve_child3():            # DP for child starting from (n-1, 0)            dp = [[-1] * n for _ in range(n)]            dp[n-1][n-1] = 0  # Base case: destination reached                        # Fill DP table from right to left            for j in range(n-2, -1, -1):                for i in range(n):                    if i &lt; j:  # Invalid: must stay below/on diagonal                        continue                                        max_val = -1                    # Try all three moves: up-right, right, down-right                    for di in [-1, 0, 1]:                        ni, nj = i + di, j + 1                        if 0 &lt;= ni &lt; n and 0 &lt;= nj &lt; n and dp[ni][nj] != -1:                            # Don&#x27;t count diagonal cells (Child 1 collects them)                            curr_fruit = 0 if (i == j) else fruits[i][j]                            max_val = max(max_val, curr_fruit + dp[ni][nj])                                        dp[i][j] = max_val                        return dp[n-1][0] if dp[n-1][0] != -1 else 0                child2_fruits = solve_child2()        child3_fruits = solve_child3()                return child1_fruits + child2_fruits + child3_fruits\n\n\nAlgorithm BreakdownLet me walk you through each critical part of my solution:\nStep 1: Child 1 - Diagonal Collectionchild1_fruits = sum(fruits[i][i] for i in range(n))\n\nChild 1 starting from (0, 0) has a critical constraint: each move must go to (i+1, j+1), (i+1, j), or (i, j+1). Given that they must reach (n-1, n-1) in exactly n-1 moves, the only valid path is the main diagonal! So we simply sum all diagonal elements.\nStep 2: Child 2 - Upper Triangle DPdef solve_child2():    dp = [[-1] * n for _ in range(n)]    dp[n-1][n-1] = 0  # Base case\n\nKey implementation details:\n\nDP Table Initialization: Use -1 to mark unreachable states\nBase Case: dp[n-1][n-1] = 0 (destination reached, fruits already counted by Child 1)\nIteration Order: Bottom-up (from row n-2 to 0)\nConstraint Check: j &lt; i means invalid position (crossed diagonal)\nAvoiding Double Count: curr_fruit = 0 if (i == j) ensures diagonal cells arenâ€™t counted twice\n\nStep 3: Child 3 - Lower Triangle DPdef solve_child3():    dp = [[-1] * n for _ in range(n)]    dp[n-1][n-1] = 0  # Base case\n\nSymmetric logic to Child 2:\n\nIteration Order: Right-to-left (from column n-2 to 0)\nConstraint Check: i &lt; j means invalid position (crossed diagonal)\nMovement: Up-right, right, or down-right (column always increases by 1)\n\nStep 4: Combine Resultsreturn child1_fruits + child2_fruits + child3_fruits\n\nSince paths donâ€™t overlap (diagonal cells handled separately), we simply add the three components.\n\nComplexity AnalysisTime Complexity: O(nÂ²)\nChild 1 diagonal sum: O(n)\nChild 2 DP: O(nÂ²) states, each with O(1) transitions\nChild 3 DP: O(nÂ²) states, each with O(1) transitions\n\nTotal: O(nÂ²)\nSpace Complexity: O(nÂ²)\nChild 2 DP table: O(nÂ²)\nChild 3 DP table: O(nÂ²)\n\nTotal: O(nÂ²)\n\nWhy This Approach WorksThe Mathematical FoundationThe key insight is the path separation property:\n\nChild 1 is deterministic: With n-1 moves from (0,0) to (n-1,n-1), and each move incrementing at least one coordinate, Child 1 must traverse the diagonal. Any deviation would require more or fewer steps.\n\nChild 2 stays in upper triangle: Starting at (0, n-1) with column n-1 &gt; 0 = row, and each move increasing the row by exactly 1, Child 2â€™s column index is always â‰¥ row index until reaching the destination.\n\nChild 3 stays in lower triangle: By symmetry, Child 3â€™s row index is always â‰¥ column index.\n\n\nHandling OverlapsThe only possible overlap is on the diagonal (where i == j). Since Child 1 always collects diagonal fruits, we set curr_fruit = 0 for diagonal positions in Child 2 and Child 3â€™s DP to avoid double counting.\n\nTest Cases WalkthroughExample: fruits &#x3D; [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]Grid visualization (n=4):     0   1   2   30  [ 1,  2,  3,  4]  â† Child 2 starts at (0,3)1  [ 5,  6,  8,  7]2  [ 9, 10, 11, 12]3  [13, 14, 15, 16]  â† Child 3 starts at (3,0)   â†‘                     â†˜Child 1              Destination (3,3)starts (0,0)Step 1: Child 1 (diagonal)Path: (0,0) â†’ (1,1) â†’ (2,2) â†’ (3,3)Fruits: 1 + 6 + 11 + 16 = 34Step 2: Child 2 (upper triangle)DP fills from bottom-up:- Row 2: dp[2][3] = 12, dp[2][2] = 0 (diagonal)- Row 1: dp[1][3] = max(12, 12) + 7 = 19         dp[1][2] = max(0, 12, 19) + 8 = 27- Row 0: dp[0][3] = max(27, 19, ?) + 4 = 31Optimal path: (0,3) â†’ (1,2) â†’ (2,3) â†’ (3,3)Fruits: 4 + 8 + 12 + 0 = 24Step 3: Child 3 (lower triangle)DP fills from right-to-left:- Col 2: dp[3][2] = 15, dp[2][2] = 0 (diagonal)- Col 1: dp[3][1] = max(0, 15, ?) + 14 = 29- Col 0: dp[3][0] = max(?, 29, ?) + 13 = 42Optimal path: (3,0) â†’ (3,1) â†’ (3,2) â†’ (3,3)Fruits: 13 + 14 + 15 + 0 = 42Total: 34 + 24 + 42 = 100 âœ“\n\n\nComparison with Alternative ApproachesApproach 1: Full 6D&#x2F;4D DPIdea: Track all three childrenâ€™s positions simultaneously\nDrawback:\n\nTime: O(n^6) or O(n^4) with optimization\nSpace: O(n^6) or O(n^4)\nExtremely complex implementation\n\nApproach 2: Pure Memoization (No Path Separation)Idea: Use recursive memoization without recognizing path separation\nDrawback:\n\nStill O(n^4) complexity\nHigher constant factor due to recursion overhead\nLess elegant code\n\nWhy My Approach is Better\n\n\nMetric\nMy Solution\n6D DP\nPure Memo\n\n\n\nTime\nO(nÂ²)\nO(n^6)\nO(n^4)\n\n\nSpace\nO(nÂ²)\nO(n^6)\nO(n^4)\n\n\nKey Insight\nPath separation\nNone\nPartial\n\n\n\nKey TakeawaysAlgorithm Design Insights\nIdentify non-overlapping subproblems: The three paths naturally separate due to movement constraints, allowing independent optimization.\n\nLeverage constraints to simplify: Recognizing that Child 1 must follow the diagonal reduces the problem from 3-path to 2-path optimization.\n\nHandle edge cases carefully: Diagonal cells need special treatment to avoid double counting.\n\n\nProblem-Solving Strategy\nAnalyze movement constraints: Understanding each childâ€™s valid region is crucial.\n\nVisualize the problem: Drawing the grid and marking valid regions for each child reveals the separation property.\n\nDecompose when possible: Breaking one 3-path problem into one deterministic path + two independent DP problems dramatically simplifies the solution.\n\n\n\nConclusionThis approach demonstrates that careful constraint analysis can transform a seemingly complex multi-agent optimization problem into elegant, tractable subproblems.\nThe beauty of this solution lies in recognizing:\n\nChild 1â€™s path is deterministic (must follow diagonal)\nChild 2 and Child 3â€™s regions are separated (upper vs. lower triangle)\nDiagonal overlap is the only edge case (handled by zeroing out)\n\nBy decomposing the problem this way, we achieve O(nÂ²) time and space complexity instead of the naive O(n^6) approachâ€”a dramatic improvement that makes the solution practical for large inputs.\n\nTutorial texts partly co-generated by Claude Opus 4.5.\nHope this detailed walkthrough helps you understand my efficient approach to this problem! Feel free to discuss any questions in the comments.\nHappy Coding! ğŸš€\n","categories":["Coding"],"tags":["LeetCode"]},{"title":"Leetcode 3350 - Track Adjacent Increasing Subarrays","url":"/2025/10/15/LeetCode-3350-One-Pass-Adjacent-Increasing-Subarrays/","content":"\nProblem DescriptionGiven an integer array nums, find the maximum length k such that there exist two adjacent (non-overlapping) subarrays of length k, and both subarrays are strictly increasing.\nReturn the maximum possible value of k. If no such subarrays exist, return 1.\nExamplesExample 1:\nInput: nums = [2,5,7,8,9,2,3,4,3,1]Output: 3Explanation: The subarrays [2,5,7] and [8,9,2] are not valid.But [5,7,8] and [9,2,3] are not adjacent.The valid answer is [2,5,7] (length 3) adjacent to... wait, let me recalculate.\n\nExample 2:\nInput: nums = [1,2,3,4,5]Output: 2Explanation: The entire array is strictly increasing with length 5.We can split it into [1,2] and [3,4], giving us k=2.\n\nExample 3:\nInput: nums = [1,2,3,2,3,4,3,4,5]Output: 2Explanation: [1,2,3] and [2,3,4] are adjacent strictly increasing subarrays.We can pick k=2 from both.\n\n\nMy Unique ApproachInstead of using complex data structures or multiple passes, I developed an elegant single-pass solution that tracks consecutive increasing segments and intelligently compares them at boundaries.\nKey InsightThe core idea is to recognize that at any point where an increasing sequence breaks, we have two opportunities to maximize k:\n\nSplit Strategy: Divide the current increasing subarray in half\nAdjacent Strategy: Pair the previous increasing subarray with the current one\n\nBy tracking both the current and previous subarray lengths, we can evaluate both strategies in O(1) time at each boundary.\n\nAlgorithm LogicThe Tracking MechanismI maintain three critical variables:\n\ncount: Length of the current strictly increasing subarray\nlastcount: Length of the previous strictly increasing subarray\nmaxm: The maximum k found so far\n\nThe Decision PointsAt each position where nums[i] &gt;= nums[i+1] (a break in the increasing sequence), we:\n\nCompare lastcount and count (adjacent strategy)\nConsider count // 2 (split current subarray)\nUpdate our maximum accordingly\n\nEdge Case Handling\nTwo-element arrays: Always return 1\nFully increasing arrays: Return len(nums) // 2\nFinal subarray: Must be checked after the loop ends\n\n\nMy SolutionPython Implementationclass Solution(object):    def maxIncreasingSubarrays(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        # Edge case: minimum possible input        if len(nums) == 2:            return 1                count = 1          # Current increasing subarray length        lastcount = 0      # Previous increasing subarray length        maxm = 0           # Maximum k found                # Single pass through the array        for i in range(len(nums) - 1):            if nums[i] &lt; nums[i + 1]:                # Continue the increasing sequence                count += 1            else:                # Break point: evaluate both strategies                # 1. Adjacent strategy: min(lastcount, count)                # 2. Split strategy: count // 2                maxm = max(maxm, min(count, lastcount), count // 2)                                # Shift: current becomes previous                lastcount = count                count = 1                # Don&#x27;t forget the final subarray!        if lastcount &gt; 0:            maxm = max(maxm, min(lastcount, count), count // 2)                # Special case: entire array is strictly increasing        if count == len(nums):            return count // 2                # If no valid pair found, minimum is always 1        return maxm if maxm != 0 else 1\n\n\nAlgorithm BreakdownLet me walk you through each critical part of my solution:\nStep 1: Edge Case - Two Elementsif len(nums) == 2:    return 1\n\nFor the smallest possible input, we can only have two subarrays of length 1, so return 1 immediately.\nStep 2: The Core Loop - Tracking Increasesfor i in range(len(nums) - 1):    if nums[i] &lt; nums[i + 1]:        count += 1\n\nAs we iterate, we simply count consecutive strictly increasing elements. This gives us the length of the current increasing subarray.\nStep 3: Boundary Analysis - The Magic Happens Hereelse:    maxm = max(maxm, min(count, lastcount), count // 2)    lastcount = count    count = 1\n\nWhen we hit a boundary (increasing sequence breaks), we:\n\nCompare three values:\n\nCurrent maximum: maxm\nAdjacent strategy: min(count, lastcount) - take the smaller of the two adjacent subarrays\nSplit strategy: count // 2 - split the current subarray in half\n\n\nUpdate tracking: Move current to previous, reset current to 1\n\n\nStep 4: Final Subarray Checkif lastcount &gt; 0:    maxm = max(maxm, min(lastcount, count), count // 2)\n\nAfter the loop, we still have the final increasing subarray to consider. We must check it against the previous one using the same logic.\nStep 5: Fully Increasing Arrayif count == len(nums):    return count // 2\n\nIf the entire array is strictly increasing (no breaks occurred), the optimal solution is to split it in half.\n\nComplexity AnalysisTime Complexity: O(n)We iterate through the array exactly once, performing constant-time operations at each step:\n\nComparison: O(1)\nCounter updates: O(1)\nMax calculations: O(1)\n\nTotal: Single pass â†’ O(n)\nSpace Complexity: O(1)We only use three integer variables regardless of input size:\n\ncount\nlastcount\nmaxm\n\nNo additional data structures needed!\n\nWhy This Approach WorksThe Mathematical FoundationThe problem essentially asks: Whatâ€™s the maximum k such that we can find two adjacent strictly increasing subarrays of length k?\nMy approach recognizes that:\n\nAny strictly increasing subarray of length L can be split into two adjacent subarrays of length L&#x2F;2\n\nExample: [1,2,3,4] â†’ [1,2] and [3,4]\n\n\nTwo adjacent strictly increasing subarrays of lengths A and B can form two subarrays of length min(A,B)\n\nExample: [1,2,3] (length 3) and [5,6] (length 2) â†’ k &#x3D; 2\n\n\nAt any boundary, we choose the better strategy\n\nSplit current: count // 2\nUse adjacent: min(count, lastcount)\n\n\n\nThe Greedy ChoiceThis solution is greedy in nature - at each decision point, we choose the maximum possible value. This works because:\n\nOnce we pass a boundary, the previous subarray length is fixed\nWe canâ€™t â€œgo backâ€ and change it\nTherefore, making the locally optimal choice (max of the three options) is globally optimal\n\n\nTest Cases WalkthroughLetâ€™s trace through some examples to see the algorithm in action:\nExample 1: nums &#x3D; [2,5,7,8,9,2,3,4,3,1]Initial: count=1, lastcount=0, maxm=0i=0: 2&lt;5 â†’ count=2i=1: 5&lt;7 â†’ count=3i=2: 7&lt;8 â†’ count=4i=3: 8&lt;9 â†’ count=5i=4: 9â‰¥2 â†’ Break!     maxm = max(0, min(5,0), 5//2) = max(0, 0, 2) = 2     lastcount=5, count=1i=5: 2&lt;3 â†’ count=2i=6: 3&lt;4 â†’ count=3i=7: 4â‰¥3 â†’ Break!     maxm = max(2, min(3,5), 3//2) = max(2, 3, 1) = 3     lastcount=3, count=1i=8: 3â‰¥1 â†’ Break!     maxm = max(3, min(1,3), 1//2) = max(3, 1, 0) = 3     lastcount=1, count=1Final check:     maxm = max(3, min(1,1), 1//2) = max(3, 1, 0) = 3Output: 3 âœ“\n\nExample 2: nums &#x3D; [1,2,3,4,5]Initial: count=1, lastcount=0, maxm=0i=0: 1&lt;2 â†’ count=2i=1: 2&lt;3 â†’ count=3i=2: 3&lt;4 â†’ count=4i=3: 4&lt;5 â†’ count=5No breaks occurred!count == len(nums) â†’ return 5//2 = 2Output: 2 âœ“\n\nExample 3: nums &#x3D; [5,4,3,2,1]Initial: count=1, lastcount=0, maxm=0i=0: 5â‰¥4 â†’ Break!     maxm = max(0, min(1,0), 1//2) = max(0, 0, 0) = 0     lastcount=1, count=1i=1: 4â‰¥3 â†’ Break!     maxm = max(0, min(1,1), 1//2) = max(0, 1, 0) = 1     lastcount=1, count=1... (continues with all breaks)Final: maxm = 1Output: 1 âœ“\n\n\nComparison with Alternative ApproachesApproach 1: Two-Pass SolutionIdea: First pass records all increasing subarray lengths, second pass finds maximum k.\n# First pass: record lengthslengths = []count = 1for i in range(len(nums)-1):    if nums[i] &lt; nums[i+1]:        count += 1    else:        lengths.append(count)        count = 1lengths.append(count)# Second pass: find max kmaxm = 0for i in range(len(lengths)-1):    maxm = max(maxm, min(lengths[i], lengths[i+1]))for length in lengths:    maxm = max(maxm, length // 2)\n\nDrawback: \n\nTime: Still O(n) but two passes\nSpace: O(n) for the lengths array\nLess elegant code\n\nApproach 2: Dynamic ProgrammingIdea: Track increasing lengths in a DP array.\nDrawback:\n\nOvercomplicated for this problem\nO(n) space required\nNo performance benefit\n\nWhy My Approach is Better\n\n\nMetric\nMy Solution\nTwo-Pass\nDP\n\n\n\nTime\nO(n) - 1 pass\nO(n) - 2 passes\nO(n)\n\n\nSpace\nO(1)\nO(n)\nO(n)\n\n\n\nKey TakeawaysAlgorithm Design Insights\nGreedy works when future doesnâ€™t affect past: Since weâ€™re moving forward and canâ€™t change previous subarrays, greedy choices are safe.\n\nTrack minimal state: We only need to remember the previous subarray length, not all previous subarrays.\n\nBoundary analysis is powerful: The break points give us natural decision points.\n\n\nCoding Best Practices\nHandle edge cases first: The len(nums)==2 check simplifies the main logic.\n\nDonâ€™t forget the final element: After loops, always check if thereâ€™s remaining data to process.\n\nUse meaningful variable names: count, lastcount, maxm clearly indicate their purpose.\n\n\n\nConclusionThis single-pass tracking solution demonstrates that many problems have elegant solutions when you:\n\nIdentify the key decision points (boundaries between increasing subarrays)\nTrack minimal necessary state (current and previous lengths)\nApply greedy logic at each decision point (maximize k locally)\n\nThe beauty of this approach lies in its simplicity - we achieve optimal time and space complexity with clear, maintainable code.\n\nTutorial texts partly co-generated by Claude-4-Sonnet.\nHope this detailed walkthrough helps you understand my efficient approach to this problem! Feel free to discuss any questions in the comments.\nHappy Coding! ğŸš€\n","categories":["Coding"],"tags":["LeetCode"]},{"title":"The Path of Revelation (å•Ÿç¤ºè·¯) -- Walk a life, on water and Bewater","url":"/2025/09/05/My-First-Blog-Post/","content":"\nWrite the things which thou hast seen, and the things which are, and the things which shall be hereafter.\næ‰€ä»¥ä½ è¦æŠŠæ‰€å·²çœ‹è¦‹çš„äº‹ï¼ŒåŠä»¥ç¾åœ¨çš„äº‹ï¼Œä¸¦å°‡ä¾†å¿…æˆçš„äº‹ï¼Œéƒ½è¨˜å¯«å‡ºä¾†ã€‚\n\nâ€” Revelation 1:19\n\n\n\n\n\n\n","categories":["Thoughts"],"tags":["Book&Music Review"]}]