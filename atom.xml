<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MLMZZZOOO&#39;s Blog</title>
  
  <subtitle>discover the world and share my thoughts</subtitle>
  <link href="https://miralemzhang.github.io/atom.xml" rel="self"/>
  
  <link href="https://miralemzhang.github.io/"/>
  <updated>2025-12-30T12:58:58.495Z</updated>
  <id>https://miralemzhang.github.io/</id>
  
  <author>
    <name>Miralem Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025 Annual -- æˆ‘åœ¨æœªæ¥ç­‰ä½ </title>
    <link href="https://miralemzhang.github.io/2025/12/24/2025/"/>
    <id>https://miralemzhang.github.io/2025/12/24/2025/</id>
    <published>2025-12-23T17:10:45.000Z</published>
    <updated>2025-12-30T12:58:58.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote style="border: none !important; border-left: none !important; background-color:rgb(36, 39, 43); padding: 10px; margin: 20px 0; border-radius: 8px; color: #ffffff;"><em><span style="font-size: 1.2em; color: #ffffff;"></span></em><br><em style="color: #ffffff;">L'avenir, tu n'as pas Ã  le prÃ©voir, mais Ã  le permettre... L'amour, une fois qu'il a germÃ©, donne des racines qui ne finissent plus de croÃ®tre.</em><div style="text-align: right; margin-top: 10px; font-size: 1em; color: #888;"><br>-- Terre des hommes</div></blockquote><p>miralem,</p><p>hey, ä¸€å¹´å‰çš„ä½ ï¼Œå¾ˆéš¾æƒ³è±¡åˆ°å§ã€‚</p><h2 id="i"><a href="#i" class="headerlink" title="i."></a>i.</h2><p>wow, where to start. ç¬¬ä¸€æ¬¡åœ¨åšå®¢é‡Œç”¨ä¸­æ–‡æ‰“å­—ï¼Œ</p><h2 id="ii"><a href="#ii" class="headerlink" title="ii."></a>ii.</h2><p>â€œJâ€™ai vu la flamme de la libertÃ© faire resplendir les hommes, et la tyrannie les abrutir.â€</p><p>è€Œé‚£åœ°æ–¹ï¼Œæˆ‘çŸ¥é“å®ƒåº”è®¸çš„ä¸èƒ½ä¹Ÿä¸ä¼šæ˜¯å±äºæˆ‘çœŸæ­£çš„å±±ï¼Œä¹Ÿä¸æ˜¯ä»–ä»¬è¶³å¤Ÿå®Œç¾ï¼Œåªæ˜¯ä»¿ä½›ï¼Œä»æ–‡æ˜çš„è§†è§’çœ‹ï¼Œä¼¼ä¹ä»…ä»…å› ä¸ºæ›´ç†Ÿæ‚‰ä»–ä»¬çœ¼ä¸­æ´‹æº¢çš„å¿«ä¹ï¼Œå¿ƒåº•æµæ·Œçš„è‡ªç”±ï¼Œä½†å¥½åƒè¿™äº›ä¹Ÿè¶³å¤Ÿäº†ã€‚ä½ é‡è¿‡å¤ªå¤šåŒªå¤·æ‰€æ€ï¼Œè§è¿‡å¤ªå¤šè’è°¬è‡³æï¼Œå¯ä½ è¿˜æ˜¯é€‰æ‹©å»ç›¸ä¿¡ï¼Œå»æ‹¥æŠ±ï¼Œå»å‹‡æ•¢ã€‚</p><p>å› ä¸ºä½ åœ¨å¥½å¤šå¹´å‰é‚£äº›é—·çƒ­çš„åˆåé‡Œæ‡µå›°åœ°å­¦è¯»çš„è¯­æ³•ä¹¦çœŸæ˜¯å¯¹çš„ï¼Œä¸€ä¸ªäººåªæœ‰å…ˆè€•ç§æ‰èƒ½æ”¶è·ï¼Œå…ˆè¿›è¡Œæ‰ä¼šå®Œæˆï¼›å…ˆç¦»å¼€ï¼Œæ‰æœ‰å½’æ¥ã€‚</p><p>æ€»ä¼šæ¢¦æƒ³äººäººéƒ½å¯ä»¥åšä¸€ä¸ªæœ‰å°Šä¸¥çš„äººï¼Œ</p><p>äººäººèƒ½ä»¥æˆ‘ç¬”å†™æˆ‘ä¿¡ã€æˆ‘å£è¯´æˆ‘å£°ã€‚</p><p>æ‰€ä»¥ï¼Œè¿™å¹´ä½ ä¼šå»æ„Ÿæ©</p><p>åšäº†å¯èƒ½æ˜¯äººç”Ÿé‡Œæœ€ç–¯ç‹‚çš„å†³å®šï¼Œ</p><p>è¿˜æœ‰ä¸€è·¯éƒ½èƒ½å¸®åŠ©æˆ‘ã€ç›¸ä¿¡æˆ‘ã€é¼“åŠ±æˆ‘çš„ä½ ä»¬ã€‚å¥½å¸Œæœ›æ²¡æœ‰è¾œè´Ÿå¤ªå¤šã€‚</p><h2 id="iii-Euphoria"><a href="#iii-Euphoria" class="headerlink" title="iii. Euphoria"></a>iii. Euphoria</h2><p>å’ŒZJU-Chinaè¿™åº§æˆ‘æ°¸è¿œçš„å®¶ã€‚å†¬å¤æ˜¥ç§‹ï¼Œ</p><p>å·´é»çš„æœˆå¤œã€é‡Œæ˜‚çš„æ™¨å…‰ï¼Œ   å¤šå¹¸è¿æˆ‘ä»¬èƒ½ä¸€èµ·å¥”èµ´ã€‚<br>åˆ†æ‹…å¯’æ½®ã€é£é›·ã€éœ¹é›³ï¼›<br>å…±äº«é›¾éœ­ã€æµå²šã€è™¹éœ“ã€‚</p><p>è®©æˆ‘ç›¸ä¿¡</p><p>é‡è¦çš„ä¸æ˜¯ä¸–äº‹æœ‰æ— å¦‚æœï¼Œè€Œæ˜¯<br>ç„¶åéª„å‚²åœ°ç‡ƒèµ·æ¯ä¸€åˆ»çœ¼å‰<br>å¼•ç€æˆ‘è·‘ï¼Œå¤©ç©ºæ²¡æœ‰æé™</p><h2 id="iv-æœªæ¥æ­Œ"><a href="#iv-æœªæ¥æ­Œ" class="headerlink" title="iv. æœªæ¥æ­Œ"></a>iv. æœªæ¥æ­Œ</h2><p>å½“ä½ èµ°åˆ°å±±å¡ä¸­æ®µçš„æ—¶å€™ï¼Œçœ‹ä¸åˆ°å±±é¡¶çš„é£æ™¯ï¼Œä½ åªèƒ½çœ‹åˆ°è„šä¸‹çš„è·¯ï¼Œä½ åªèƒ½çœ‹åˆ°èº«è¾¹è‡ªå·±çš„å½±å­ï¼Œ<br>æˆ–è®¸å°±æ˜¯æœ€æƒ³æ”¾å¼ƒçš„æ—¶å€™ï¼Œå› ä¸ºä½ åœ¨çŠ¹è±«åº”è¯¥è¦å›å¤´ï¼Œ<br>è¿˜æ˜¯è¦ç»§ç»­å‘ä¸Šè¡Œã€‚</p><p>ä½ çœ‹ï¼Œæˆ‘è¿˜æ˜¯è¿™æ ·ï¼Œä¸€æ•´å¹´éƒ½è¿˜åœ¨æ‰¾ç€è‡ªå·±åˆ°åº•æƒ³è¦ä»€ä¹ˆã€‚æˆ‘ä¼šè¯´å‡ºå£æˆ‘å¾ˆç—›è‹¦ï¼Œå› ä¸ºæˆ‘çŸ¥é“ç°åœ¨æˆ‘æ‰€æœ‰æ‰€åœ¨è¿™äº›æ ¹æœ¬è¿œè¿œä¸å¤Ÿæˆ‘æ‰€æƒ³è¦çš„ï¼Œæœ‰äº›äº‹æƒ…ä¹Ÿä¸æ˜¯é ç€é•¿å¤§å°±èƒ½æœ‰ç­”æ¡ˆã€‚åŒ—æ–¹çŒç€åˆºéª¨çš„é£ï¼Œæ­å·æ ¹æœ¬å°±ä¸æ˜¯äººä½çš„åœ°æ–¹æ²¡æœ‰â€œè‡ªä¸»çš„æ¸©æš–â€ï¼Œ   ï¼Œèº«åæ˜¯ç´§è¿½ä¸èˆçš„   ï¼Œæˆ‘å´å¾®ç¬‘ç€æƒ³åˆ°äº†</p><p>ä½†æˆ‘ä¹Ÿå¾ˆå¿«ä¹ï¼Œå› ä¸ºæˆ‘çŸ¥é“</p><p>ä½ çœ‹ï¼Œé‚£äº›ä½ åŸæœ¬æ²¡æ³•æƒ³è±¡çš„æœºä¼šã€é‚£äº›ä½ å·®ç‚¹è®¤å®šå°±æ“¦èº«è€Œè¿‡çš„æ¢¦æƒ³ï¼Œç”šè‡³é‚£ä¸ªä½ ä»¥ä¸ºé¥ä¸å¯åŠçš„27fallï¼Œä¸æ˜¯éƒ½ç«Ÿè¿‘åœ¨çœ¼å‰äº†å—ã€‚<br>â€œé‚£ä¹ˆï¼Œâ€æˆ‘æ€»è®°å¾—ä½ åœ¨åˆä¸­å°±å¾ˆå–œæ¬¢çš„è¿™äº›è¯ï¼Œå°±å¥½åƒä½ ä¼šåœ¨é‚£æ™šä¸‹ç¬”æ—¶å°±æƒ³åˆ°å’Œæœªæ¥çš„æˆ‘è¯´ï¼Œâ€œé‚£ä¹ˆï¼Œä»æ˜¯è¦å»åšä½ è§‰å¾—å¯¹çš„äº‹æƒ…ï¼Œå»æ•¢çˆ±ï¼Œå»æ•¢æ¨ï¼Œæ•¢è¯´ï¼Œæ•¢åšï¼Œæ•¢è¿½æ±‚â€¦â€¦â€<br>â€œåˆ«å»å®³æ€•åˆ¹é‚£ï¼Œé‚£äº›äººåªèƒ½ä¸€è¾ˆå­å¾…ç€è¿™é‡Œè€Œå·²â€¦â€¦ä½ ä»¬è¯¥æœ‰â€<br>â€œè¿™äº›ï¼Œæˆ‘æ€•çœ‹ä¸åˆ°çš„ï¼Œä½†æˆ‘çŸ¥é“æ€»æœ‰å¤©ä½ æœ‰æ–°çš„æ—…ç¨‹ï¼Œæ‰€ä»¥åˆ«ç•™é—æ†¾å§ï¼â€¦â€¦å°†æ¥çš„ä½ ï¼Œä¸€å®šä¸€å®šå¯ä»¥çœ‹å¾—åˆ°ã€‚â€</p><p>æˆ‘æ›´å¹¸è¿ï¼Œ</p><p>æˆ‘ä¸å®³æ€•ã€‚</p><p>æˆ‘ç›¸ä¿¡çš„ï¼Œå†é€‰æ‹©ï¼Œä½ è¿˜æ˜¯ä¼šç»§ç»­å°±å»å‘ä¸Šè¡Œï¼Œä½ ä»æ¥ä»æ¥ä¸ä¼šå…è®¸è‡ªå·±å°±é‚£æ ·æŠŠè‡ªå·±ç»™æä¸¢ã€‚</p><p>æˆ‘ç°åœ¨å°±é€‰æ‹©ç»§ç»­å‘ä¸Šè¡Œã€‚</p><h2 id="v-ã€Œç¥ä½ åœ¨äº‚æµä¸‹å¹³å®‰ã€"><a href="#v-ã€Œç¥ä½ åœ¨äº‚æµä¸‹å¹³å®‰ã€" class="headerlink" title="v. ã€Œç¥ä½ åœ¨äº‚æµä¸‹å¹³å®‰ã€"></a>v. ã€Œç¥ä½ åœ¨äº‚æµä¸‹å¹³å®‰ã€</h2><p>å°è±¡é‡Œï¼Œå°æ—¶å€™ï¼Œæ¯å¹´åœ£è¯èŠ‚ï¼Œ   ï¼Œ<br>åæ¥â€”â€”å¦‚æœé‚£äº›  è¿˜å¯ä»¥è¢«åŸè°…è€Œæ‹¼å‡‘æˆäº›â€œåæ¥â€çš„è¯â€”â€”</p><p>ä¸€å¹´å¹´ï¼Œè¿™ç§è¿‘ä¹é›†ä½“æ— æ„è¯†çš„çŠ¶æ€è¿˜æ˜¯å¤§å£°é¼“å¹æˆ‘ä»¬ä»ç„¶è¯¥æŠµåˆ¶çš„æ‰€è°“é›†ä½“ä¼¦ç†ï¼Œä½†æ˜¯æˆ‘ä»¬è‡ªå·±å´ä¸çŸ¥ä¸è§‰æ…¢æ…¢åœ°è¢«æœç€è¿™ç§ä¼¦ç†å‰è¿›ï¼Œå› ä¸ºæˆ‘ä»¬â€”â€”ä¸çŸ¥ä¸è§‰â€”â€”å¿˜è®°äº†äººï¼Œäººæ˜¯å”¯ä¸€èƒ½è§£é‡Šè¿™ç§æ‹’ç»çš„ç†ç”±ã€‚æ²‰é»˜æ¯”è’å™ªæ›´åŠ å¯æ€•ï¼Œéšæ³¢é€æµçš„åŒåŒ–æ— å¤„ä¸åœ¨ï¼Œä¸èƒ½ä¸å‘é†’å•Šï¼</p><p>äºæ˜¯ï¼Œä¹Ÿä¸€å¹´å¹´ï¼Œä½ è¿˜æ˜¯     ï¼Œæˆ‘çœ‹åˆ°äº†ï¼Œé‚£äº›     éƒ½çœ‹è§äº†ã€‚å¦‚æœæˆ‘åœ¨é»æ˜å‡ºå‘ï¼Œé‚£ä¹ˆæˆ‘åº”è¯¥çŸ¥é“ä¸ºä»€ä¹ˆæˆ‘å¦‚ä»Šè¿˜åœ¨åŠªåŠ›ï¼Œè®°ä½æˆ‘æ‰€çœ‹åˆ°çš„ã€‚æˆ‘éœ€è¦ä¸€ä¸ªç®€å•çš„ä¿¡æ¡æ¥æé†’è‡ªå·±ã€‚<br>æˆ‘åº”è¯¥ä¸ºäººè¶…è¿‡ä¸ªä½“çš„é¦–è¦åœ°ä½è€Œå¥‹æ–—ï¼Œå°±åƒæ™®éæ€§å§‹ç»ˆè¯¥æ’åœ¨ç‰¹æ®Šæ€§çš„å‰é¢ã€‚<br>æˆ‘ç›¸ä¿¡å¯¹æ™®éæ€§çš„æ¨å´‡ã€æ ‡æ¦œï¼Œå¹¶å°†æ‰€æœ‰ç‰¹å®šçš„è´¢å¯Œä¸æ™ºæ…§é›†åˆåœ¨ä¸€èµ·ï¼Œè€Œä¸”å®ƒæ˜¯å”¯ä¸€çœŸæ­£çš„ç§©åºï¼ŒåŒæ—¶ä¹Ÿæ˜¯ç”Ÿå‘½çš„ç§©åºã€‚ä½ çœ‹ï¼Œå³ä½¿æ ‘ä¹Ÿæ˜¯ç§©åºçš„ä¸€éƒ¨åˆ†ï¼Œå°½ç®¡å®ƒçš„æ ¹å’Œææ˜¯ä¸åŒçš„ã€‚<br>å› è€Œæˆ‘ç›¸ä¿¡å¯¹æŸç§æƒåŠ›æˆ–åœ°ä½ç‰¹æ®Šæ€§çš„æ¨å´‡åªä¼šå¸¦æ¥å‹è¿«ï¼Œå› ä¸ºå®ƒæ˜¯ä¼å›¾å»ºç«‹åœ¨ä»¥ç›¸ä¼¼æ€§ä¸ºåŸºç¡€çš„ç§©åºä¹‹ä¸Šçš„ä¸“åˆ¶ï¼Œæ˜¯æ‰€æœ‰æš´æ”¿çš„é›å½¢ã€‚å®ƒå°†æœ¬è´¨çš„ç»Ÿä¸€å’Œéƒ¨åˆ†çš„è®¤åŒæ··æ·†ã€‚å› æ­¤æˆ‘åº”è¯¥åå¯¹é‚£äº›æƒ³è¦å°†ç‹¬è£çš„ç¤¾ä¼šæ–¹å¼å¼ºåŠ äºå…¶å®ƒç¤¾ä¼šæ–¹å¼ï¼Œå°†ç‹¬ç‰¹çš„â€œäººâ€å¼ºåŠ äºå…¶ä»–äººï¼Œå°†æŸä¸ªç‰¹å®šçš„å›½æ—å¼ºå‡Œé©¾äºå…¶ä»–çš„å›½æ—ï¼Œå°†ä¸€ç§ç‹¬ç‰¹çš„æ€ç»´æ„è¯†å¼ºåŠ äºå…¶ä»–çš„æ€ç»´æ„è¯†çš„äººã€‚<br>æˆ‘è¯¥ç›¸ä¿¡å¼ºè°ƒäººçš„é¦–è¦åœ°ä½æ˜¯å”¯ä¸€æœ‰æ„ä¹‰çš„å¹³ç­‰å’Œè‡ªç”±çš„åŸºç¡€ï¼Œæˆ‘ä¹Ÿä¼šç›¸ä¿¡è‡ªç”±æ˜¯èƒ½æŠ•å½±åœ¨æœªæ¥é‡Œçš„æ‰€æœ‰äººå¾—ä»¥è¿½æ±‚å‘ä¸Šçš„è‡ªç”±ã€‚å¹³ç­‰ä¸æ˜¯è®¤åŒï¼Œè‡ªç”±ä¹Ÿä¸ä¼šæ˜¯ä¸ªäººå’Œäººçš„å¯¹æŠ—çš„æ”¾å¤§ã€‚æˆ‘åº”è¯¥è®°ä½åå¯¹ä»»ä½•æƒ³è¦å€Ÿç€è™šä¼ªä»¥å¥´å½¹æ— è®ºæ˜¯ä¸ªäººè¿˜æ˜¯ç”±ä¸ªäººç»„æˆçš„é›†ä½“çš„è‡ªç”±çš„äººã€‚<br>æˆ‘ç›¸ä¿¡çœŸæ­£çš„æ–‡æ˜å°†æŠŠäººä¸ºè¿™è€Œåšå‡ºçš„ç‰ºç‰²ä»¥å‘½åçš„è‡ªç”±ï¼Œå¹¶ä½œä¸ºå®ƒå”¯ä¸€å¾—ç»Ÿæ²»çš„åŸºç¡€ã€‚è‡ªç”±æ˜¯ç»™äººçš„ç¬¬ä¸€ä¸ªç¤¼ç‰©ï¼Œæ˜¯è¶…è¶Šäº†ä¸ªäººçš„å¹³åº¸çš„ï¼šå®ƒåˆ›é€ äº†äººã€‚æˆ‘å°†åå¯¹ä»»ä½•å£°ç§°æˆ‘çš„è‡ªç”±æ˜¯ç»™å¹³åº¸è‡´æ•¬ï¼Œå¦å®šâ€œäººâ€ï¼Œå¹¶å°†ä¸ªäººæ¡æ¢äºâ€œä¸»ä¹‰â€ä¹‹å†…ã€å›šç¦åœ¨å¹³åº¸ä¹‹ä¸­çš„äººã€‚<br>ä¹±æµä¹‹ä¸­ï¼Œæˆ‘åº”è¯¥ä¸ºäº†äººè€Œæˆ˜æ–—ï¼Œè·Ÿä»–çš„æ•Œäººæˆ˜æ–—ï¼ŒåŒæ ·ä¹ŸåŒæˆ‘è‡ªå·±æˆ˜æ–—ã€‚</p><p>å¤šè°¢ä½ è‡ªå·±ï¼Œ  æˆ‘ä»¬æ€»èƒ½</p><p>éª„å‚²åšå¤§å†™çš„äººã€‚</p><p>â€œä¸ºè‡ªç”±çš„ç‰ºç‰²ç¥ç¦ï¼Œæ˜¯æ–‡æ˜åŠ è¯¸æ¯ä¸ªæˆ‘ä»¬çš„å‡†åˆ™ã€‚â€<br>ä»æ¥ä¸å¿…å¤©æ°”å¤šæ™´æœ—ï¼Œå·¨åŒ çš„æ‰‹ä¸æ€•éª¯é«’.<br>you can hear me,<br>æ˜å¹´è§ æœªæ¥è§.<br>å±±é¡¶è§ï¼</p><br><br>sincerely,<div style="text-align: right;"><br>mlmzzzooo<br>31/12/2025<br></div><br><br><br><br><br><br><br>]]></content>
    
    
    <summary type="html">ä½ çœ‹ï¼Œè¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬ä¸€æ¬¡æ¬¡å¥”èµ´ï¼Œä»»ä½•äº‹ç‰©éƒ½æœ‰å±äºå®ƒçš„å…‰äº®.</summary>
    
    
    
    <category term="Thoughts" scheme="https://miralemzhang.github.io/categories/Thoughts/"/>
    
    
    <category term="Annual Review" scheme="https://miralemzhang.github.io/tags/Annual-Review/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3363 - Find the Maximum Number of Fruits Collected</title>
    <link href="https://miralemzhang.github.io/2025/11/07/LeetCode-3363-Find-Maximum-Number-of-Fruits-Collected/"/>
    <id>https://miralemzhang.github.io/2025/11/07/LeetCode-3363-Find-Maximum-Number-of-Fruits-Collected/</id>
    <published>2025-11-07T13:20:05.000Z</published>
    <updated>2025-12-30T10:33:31.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>There is a game dungeon comprised of <code>n x n</code> rooms arranged in a grid.</p><p>You are given a 2D array <code>fruits</code> of size <code>n x n</code>, where <code>fruits[i][j]</code> represents the number of fruits in the room at position <code>(i, j)</code>. Three children will play in the game dungeon, with <strong>initial positions</strong> at the corner rooms <code>(0, 0)</code>, <code>(0, n - 1)</code>, and <code>(n - 1, 0)</code>.</p><p>The children will make <strong>exactly</strong> <code>n - 1</code> moves according to the following rules to reach the room <code>(n - 1, n - 1)</code>:</p><ul><li>The child starting from <code>(0, 0)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i + 1, j + 1)</code>, <code>(i + 1, j)</code>, or <code>(i, j + 1)</code> if the target room exists.</li><li>The child starting from <code>(0, n - 1)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, or <code>(i + 1, j + 1)</code> if the target room exists.</li><li>The child starting from <code>(n - 1, 0)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i - 1, j + 1)</code>, <code>(i, j + 1)</code>, or <code>(i + 1, j + 1)</code> if the target room exists.</li></ul><p>When a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave.</p><p>Return the <strong>maximum</strong> number of fruits the children can collect from the dungeon.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]</span><br><span class="line">Output: 100</span><br><span class="line">Explanation: </span><br><span class="line">- Child 1 (from (0,0)): (0,0) â†’ (1,1) â†’ (2,2) â†’ (3,3)</span><br><span class="line">- Child 2 (from (0,3)): (0,3) â†’ (1,3) â†’ (2,3) â†’ (3,3)</span><br><span class="line">- Child 3 (from (3,0)): (3,0) â†’ (3,1) â†’ (3,2) â†’ (3,3)</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: fruits = [[1,1],[1,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: All children end up at (1,1) collecting all fruits.</span><br></pre></td></tr></table></figure><hr><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><p>When I first encountered this problem, my intuition was that this is a <strong>multi-path dynamic programming problem</strong>. Three children start from different positions simultaneously and must reach the same destination <code>(n-1, n-1)</code> in exactly <code>n-1</code> steps, with the constraint that when multiple children enter the same room, only one can collect the fruits.</p><p>This reminded me of a variant of the classic <strong>â€œCherry Pickupâ€</strong> problem, but with three paths instead of two, which significantly increases the complexity. The key insight is that we need to simultaneously track the position states of all three children and correctly handle fruit collection in overlapping rooms.</p><hr><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>I adopted a <strong>4-dimensional dynamic programming</strong> approach:</p><h3 id="State-Definition"><a href="#State-Definition" class="headerlink" title="State Definition"></a>State Definition</h3><p><code>dp(step, pos_1, pos_2, pos_3)</code> represents the maximum number of fruits that can be collected when the three children are at positions <code>pos_1</code>, <code>pos_2</code>, <code>pos_3</code> respectively at step <code>step</code>.</p><h3 id="Movement-Rules"><a href="#Movement-Rules" class="headerlink" title="Movement Rules"></a>Movement Rules</h3><p>Each child has different movement constraints:</p><ul><li><strong>Child 1</strong> (starting from <code>(0,0)</code>): can move right <code>(i,j+1)</code>, down <code>(i+1,j)</code>, or diagonally down-right <code>(i+1,j+1)</code></li><li><strong>Child 2</strong> (starting from <code>(0,n-1)</code>): can move down-left <code>(i+1,j-1)</code>, down <code>(i+1,j)</code>, or down-right <code>(i+1,j+1)</code></li><li><strong>Child 3</strong> (starting from <code>(n-1,0)</code>): can move up-right <code>(i-1,j+1)</code>, right <code>(i,j+1)</code>, or down-right <code>(i+1,j+1)</code></li></ul><h3 id="State-Transition"><a href="#State-Transition" class="headerlink" title="State Transition"></a>State Transition</h3><p>For each state <code>(step, pos_1, pos_2, pos_3)</code>:</p><ol><li><strong>Calculate current reward</strong>: Sum up fruits at the three childrenâ€™s current positions, counting overlapping positions only once.</li><li><strong>Try all movement combinations</strong>: Each child chooses their next position according to their movement rules.</li><li><strong>Recursive solution</strong>: Recursively calculate the maximum future reward for each movement combination.</li><li><strong>Take maximum</strong>: Choose the maximum value among all possible combinations.</li></ol><h3 id="Base-Case"><a href="#Base-Case" class="headerlink" title="Base Case"></a>Base Case</h3><p>When <code>step = n-1</code>, check if all three children have reached the target position <code>(n-1, n-1)</code>:</p><ul><li>If all reached: return the fruit count at that position (can only be collected once).</li><li>Otherwise: return <code>-âˆ</code> to indicate an invalid state.</li></ul><h3 id="Memoization-Optimization"><a href="#Memoization-Optimization" class="headerlink" title="Memoization Optimization"></a>Memoization Optimization</h3><p>Use a dictionary <code>memo</code> to cache computed states and avoid redundant calculations.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">step, pos1, pos2, pos3</span>):</span><br><span class="line">    <span class="comment"># Check cache</span></span><br><span class="line">    <span class="keyword">if</span> (step, pos1, pos2, pos3) <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[(step, pos1, pos2, pos3)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Base case</span></span><br><span class="line">    <span class="keyword">if</span> step == n - <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Check if all reached target position</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Calculate current reward + recursively solve future reward</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># Cache result and return</span></span><br></pre></td></tr></table></figure><hr><h2 id="Key-Insight-Path-Decomposition"><a href="#Key-Insight-Path-Decomposition" class="headerlink" title="Key Insight: Path Decomposition"></a>Key Insight: Path Decomposition</h2><p>A crucial observation simplifies this problem dramatically:</p><ol><li><p><strong>Child 1 is locked to the diagonal</strong>: Due to movement constraints and the requirement to reach <code>(n-1, n-1)</code> in exactly <code>n-1</code> steps, Child 1 <strong>must</strong> follow the main diagonal path <code>(0,0) â†’ (1,1) â†’ ... â†’ (n-1,n-1)</code>.</p></li><li><p><strong>Child 2 stays above the diagonal</strong>: Starting at <code>(0, n-1)</code> and moving downward, Child 2â€™s valid positions satisfy <code>j â‰¥ i</code>.</p></li><li><p><strong>Child 3 stays below the diagonal</strong>: Starting at <code>(n-1, 0)</code> and moving rightward, Child 3â€™s valid positions satisfy <code>i â‰¥ j</code>.</p></li></ol><p>This means the three paths <strong>naturally donâ€™t overlap</strong> (except at the destination), allowing us to solve three independent subproblems!</p><hr><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxCollectedFruits</span>(<span class="params">self, fruits</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(fruits)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Child 1: Must follow the diagonal path</span></span><br><span class="line">        child1_fruits = <span class="built_in">sum</span>(fruits[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">solve_child2</span>():</span><br><span class="line">            <span class="comment"># DP for child starting from (0, n-1)</span></span><br><span class="line">            dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case: destination reached</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Fill DP table from bottom to top</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> j &lt; i:  <span class="comment"># Invalid: must stay above/on diagonal</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    max_val = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># Try all three moves: down-left, down, down-right</span></span><br><span class="line">                    <span class="keyword">for</span> dj <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">                        ni, nj = i + <span class="number">1</span>, j + dj</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= ni &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= nj &lt; n <span class="keyword">and</span> dp[ni][nj] != -<span class="number">1</span>:</span><br><span class="line">                            <span class="comment"># Don&#x27;t count diagonal cells (Child 1 collects them)</span></span><br><span class="line">                            curr_fruit = <span class="number">0</span> <span class="keyword">if</span> (i == j) <span class="keyword">else</span> fruits[i][j]</span><br><span class="line">                            max_val = <span class="built_in">max</span>(max_val, curr_fruit + dp[ni][nj])</span><br><span class="line">                    </span><br><span class="line">                    dp[i][j] = max_val</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>] <span class="keyword">if</span> dp[<span class="number">0</span>][n-<span class="number">1</span>] != -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">solve_child3</span>():</span><br><span class="line">            <span class="comment"># DP for child starting from (n-1, 0)</span></span><br><span class="line">            dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case: destination reached</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Fill DP table from right to left</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:  <span class="comment"># Invalid: must stay below/on diagonal</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    max_val = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># Try all three moves: up-right, right, down-right</span></span><br><span class="line">                    <span class="keyword">for</span> di <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">                        ni, nj = i + di, j + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= ni &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= nj &lt; n <span class="keyword">and</span> dp[ni][nj] != -<span class="number">1</span>:</span><br><span class="line">                            <span class="comment"># Don&#x27;t count diagonal cells (Child 1 collects them)</span></span><br><span class="line">                            curr_fruit = <span class="number">0</span> <span class="keyword">if</span> (i == j) <span class="keyword">else</span> fruits[i][j]</span><br><span class="line">                            max_val = <span class="built_in">max</span>(max_val, curr_fruit + dp[ni][nj])</span><br><span class="line">                    </span><br><span class="line">                    dp[i][j] = max_val</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> dp[n-<span class="number">1</span>][<span class="number">0</span>] != -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        child2_fruits = solve_child2()</span><br><span class="line">        child3_fruits = solve_child3()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> child1_fruits + child2_fruits + child3_fruits</span><br></pre></td></tr></table></figure><hr><h2 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h2><p>Let me walk you through each critical part of my solution:</p><h3 id="Step-1-Child-1-Diagonal-Collection"><a href="#Step-1-Child-1-Diagonal-Collection" class="headerlink" title="Step 1: Child 1 - Diagonal Collection"></a>Step 1: Child 1 - Diagonal Collection</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child1_fruits = <span class="built_in">sum</span>(fruits[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure><p>Child 1 starting from <code>(0, 0)</code> has a critical constraint: each move must go to <code>(i+1, j+1)</code>, <code>(i+1, j)</code>, or <code>(i, j+1)</code>. Given that they must reach <code>(n-1, n-1)</code> in exactly <code>n-1</code> moves, the <strong>only valid path</strong> is the main diagonal! So we simply sum all diagonal elements.</p><h3 id="Step-2-Child-2-Upper-Triangle-DP"><a href="#Step-2-Child-2-Upper-Triangle-DP" class="headerlink" title="Step 2: Child 2 - Upper Triangle DP"></a>Step 2: Child 2 - Upper Triangle DP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve_child2</span>():</span><br><span class="line">    dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case</span></span><br></pre></td></tr></table></figure><p>Key implementation details:</p><ol><li><strong>DP Table Initialization</strong>: Use <code>-1</code> to mark unreachable states</li><li><strong>Base Case</strong>: <code>dp[n-1][n-1] = 0</code> (destination reached, fruits already counted by Child 1)</li><li><strong>Iteration Order</strong>: Bottom-up (from row <code>n-2</code> to <code>0</code>)</li><li><strong>Constraint Check</strong>: <code>j &lt; i</code> means invalid position (crossed diagonal)</li><li><strong>Avoiding Double Count</strong>: <code>curr_fruit = 0 if (i == j)</code> ensures diagonal cells arenâ€™t counted twice</li></ol><h3 id="Step-3-Child-3-Lower-Triangle-DP"><a href="#Step-3-Child-3-Lower-Triangle-DP" class="headerlink" title="Step 3: Child 3 - Lower Triangle DP"></a>Step 3: Child 3 - Lower Triangle DP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve_child3</span>():</span><br><span class="line">    dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case</span></span><br></pre></td></tr></table></figure><p>Symmetric logic to Child 2:</p><ol><li><strong>Iteration Order</strong>: Right-to-left (from column <code>n-2</code> to <code>0</code>)</li><li><strong>Constraint Check</strong>: <code>i &lt; j</code> means invalid position (crossed diagonal)</li><li><strong>Movement</strong>: Up-right, right, or down-right (column always increases by 1)</li></ol><h3 id="Step-4-Combine-Results"><a href="#Step-4-Combine-Results" class="headerlink" title="Step 4: Combine Results"></a>Step 4: Combine Results</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> child1_fruits + child2_fruits + child3_fruits</span><br></pre></td></tr></table></figure><p>Since paths donâ€™t overlap (diagonal cells handled separately), we simply add the three components.</p><hr><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><h3 id="Time-Complexity-O-nÂ²"><a href="#Time-Complexity-O-nÂ²" class="headerlink" title="Time Complexity: O(nÂ²)"></a>Time Complexity: <strong>O(nÂ²)</strong></h3><ul><li>Child 1 diagonal sum: O(n)</li><li>Child 2 DP: O(nÂ²) states, each with O(1) transitions</li><li>Child 3 DP: O(nÂ²) states, each with O(1) transitions</li></ul><p><strong>Total</strong>: O(nÂ²)</p><h3 id="Space-Complexity-O-nÂ²"><a href="#Space-Complexity-O-nÂ²" class="headerlink" title="Space Complexity: O(nÂ²)"></a>Space Complexity: <strong>O(nÂ²)</strong></h3><ul><li>Child 2 DP table: O(nÂ²)</li><li>Child 3 DP table: O(nÂ²)</li></ul><p><strong>Total</strong>: O(nÂ²)</p><hr><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>The key insight is the <strong>path separation</strong> property:</p><ol><li><p><strong>Child 1 is deterministic</strong>: With <code>n-1</code> moves from <code>(0,0)</code> to <code>(n-1,n-1)</code>, and each move incrementing at least one coordinate, Child 1 must traverse the diagonal. Any deviation would require more or fewer steps.</p></li><li><p><strong>Child 2 stays in upper triangle</strong>: Starting at <code>(0, n-1)</code> with column <code>n-1 &gt; 0 = row</code>, and each move increasing the row by exactly 1, Child 2â€™s column index is always â‰¥ row index until reaching the destination.</p></li><li><p><strong>Child 3 stays in lower triangle</strong>: By symmetry, Child 3â€™s row index is always â‰¥ column index.</p></li></ol><h3 id="Handling-Overlaps"><a href="#Handling-Overlaps" class="headerlink" title="Handling Overlaps"></a>Handling Overlaps</h3><p>The only possible overlap is on the <strong>diagonal</strong> (where <code>i == j</code>). Since Child 1 always collects diagonal fruits, we set <code>curr_fruit = 0</code> for diagonal positions in Child 2 and Child 3â€™s DP to avoid double counting.</p><hr><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><h3 id="Example-fruits-1-2-3-4-5-6-8-7-9-10-11-12-13-14-15-16"><a href="#Example-fruits-1-2-3-4-5-6-8-7-9-10-11-12-13-14-15-16" class="headerlink" title="Example: fruits &#x3D; [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]"></a>Example: fruits &#x3D; [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Grid visualization (n=4):</span><br><span class="line">     0   1   2   3</span><br><span class="line">0  [ 1,  2,  3,  4]  â† Child 2 starts at (0,3)</span><br><span class="line">1  [ 5,  6,  8,  7]</span><br><span class="line">2  [ 9, 10, 11, 12]</span><br><span class="line">3  [13, 14, 15, 16]  â† Child 3 starts at (3,0)</span><br><span class="line">   â†‘                     â†˜</span><br><span class="line">Child 1              Destination (3,3)</span><br><span class="line">starts (0,0)</span><br><span class="line"></span><br><span class="line">Step 1: Child 1 (diagonal)</span><br><span class="line">Path: (0,0) â†’ (1,1) â†’ (2,2) â†’ (3,3)</span><br><span class="line">Fruits: 1 + 6 + 11 + 16 = 34</span><br><span class="line"></span><br><span class="line">Step 2: Child 2 (upper triangle)</span><br><span class="line">DP fills from bottom-up:</span><br><span class="line">- Row 2: dp[2][3] = 12, dp[2][2] = 0 (diagonal)</span><br><span class="line">- Row 1: dp[1][3] = max(12, 12) + 7 = 19</span><br><span class="line">         dp[1][2] = max(0, 12, 19) + 8 = 27</span><br><span class="line">- Row 0: dp[0][3] = max(27, 19, ?) + 4 = 31</span><br><span class="line">Optimal path: (0,3) â†’ (1,2) â†’ (2,3) â†’ (3,3)</span><br><span class="line">Fruits: 4 + 8 + 12 + 0 = 24</span><br><span class="line"></span><br><span class="line">Step 3: Child 3 (lower triangle)</span><br><span class="line">DP fills from right-to-left:</span><br><span class="line">- Col 2: dp[3][2] = 15, dp[2][2] = 0 (diagonal)</span><br><span class="line">- Col 1: dp[3][1] = max(0, 15, ?) + 14 = 29</span><br><span class="line">- Col 0: dp[3][0] = max(?, 29, ?) + 13 = 42</span><br><span class="line">Optimal path: (3,0) â†’ (3,1) â†’ (3,2) â†’ (3,3)</span><br><span class="line">Fruits: 13 + 14 + 15 + 0 = 42</span><br><span class="line"></span><br><span class="line">Total: 34 + 24 + 42 = 100 âœ“</span><br></pre></td></tr></table></figure><hr><h2 id="Comparison-with-Alternative-Approaches"><a href="#Comparison-with-Alternative-Approaches" class="headerlink" title="Comparison with Alternative Approaches"></a>Comparison with Alternative Approaches</h2><h3 id="Approach-1-Full-6D-4D-DP"><a href="#Approach-1-Full-6D-4D-DP" class="headerlink" title="Approach 1: Full 6D&#x2F;4D DP"></a>Approach 1: Full 6D&#x2F;4D DP</h3><p><strong>Idea</strong>: Track all three childrenâ€™s positions simultaneously</p><p><strong>Drawback</strong>:</p><ul><li>Time: O(n^6) or O(n^4) with optimization</li><li>Space: O(n^6) or O(n^4)</li><li>Extremely complex implementation</li></ul><h3 id="Approach-2-Pure-Memoization-No-Path-Separation"><a href="#Approach-2-Pure-Memoization-No-Path-Separation" class="headerlink" title="Approach 2: Pure Memoization (No Path Separation)"></a>Approach 2: Pure Memoization (No Path Separation)</h3><p><strong>Idea</strong>: Use recursive memoization without recognizing path separation</p><p><strong>Drawback</strong>:</p><ul><li>Still O(n^4) complexity</li><li>Higher constant factor due to recursion overhead</li><li>Less elegant code</li></ul><h3 id="Why-My-Approach-is-Better"><a href="#Why-My-Approach-is-Better" class="headerlink" title="Why My Approach is Better"></a>Why My Approach is Better</h3><table><thead><tr><th>Metric</th><th>My Solution</th><th>6D DP</th><th>Pure Memo</th></tr></thead><tbody><tr><td><strong>Time</strong></td><td>O(nÂ²)</td><td>O(n^6)</td><td>O(n^4)</td></tr><tr><td><strong>Space</strong></td><td>O(nÂ²)</td><td>O(n^6)</td><td>O(n^4)</td></tr><tr><td><strong>Key Insight</strong></td><td>Path separation</td><td>None</td><td>Partial</td></tr></tbody></table><hr><h2 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h2><h3 id="Algorithm-Design-Insights"><a href="#Algorithm-Design-Insights" class="headerlink" title="Algorithm Design Insights"></a>Algorithm Design Insights</h3><ol><li><p><strong>Identify non-overlapping subproblems</strong>: The three paths naturally separate due to movement constraints, allowing independent optimization.</p></li><li><p><strong>Leverage constraints to simplify</strong>: Recognizing that Child 1 must follow the diagonal reduces the problem from 3-path to 2-path optimization.</p></li><li><p><strong>Handle edge cases carefully</strong>: Diagonal cells need special treatment to avoid double counting.</p></li></ol><h3 id="Problem-Solving-Strategy"><a href="#Problem-Solving-Strategy" class="headerlink" title="Problem-Solving Strategy"></a>Problem-Solving Strategy</h3><ol><li><p><strong>Analyze movement constraints</strong>: Understanding each childâ€™s valid region is crucial.</p></li><li><p><strong>Visualize the problem</strong>: Drawing the grid and marking valid regions for each child reveals the separation property.</p></li><li><p><strong>Decompose when possible</strong>: Breaking one 3-path problem into one deterministic path + two independent DP problems dramatically simplifies the solution.</p></li></ol><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This approach demonstrates that careful constraint analysis can transform a seemingly complex multi-agent optimization problem into elegant, tractable subproblems.</p><p>The beauty of this solution lies in recognizing:</p><ol><li><strong>Child 1â€™s path is deterministic</strong> (must follow diagonal)</li><li><strong>Child 2 and Child 3â€™s regions are separated</strong> (upper vs. lower triangle)</li><li><strong>Diagonal overlap is the only edge case</strong> (handled by zeroing out)</li></ol><p>By decomposing the problem this way, we achieve <strong>O(nÂ²) time and space</strong> complexity instead of the naive O(n^6) approachâ€”a dramatic improvement that makes the solution practical for large inputs.</p><hr><p><em>Tutorial texts partly co-generated by Claude Opus 4.5.</em></p><p>Hope this detailed walkthrough helps you understand my efficient approach to this problem! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! ğŸš€</em></p>]]></content>
    
    
    <summary type="html">A memoization approach to the three-path problem: LeetCode 3363 - Find the Maximum Number of Fruits Collected.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 3350 - Track Adjacent Increasing Subarrays</title>
    <link href="https://miralemzhang.github.io/2025/10/15/LeetCode-3350-One-Pass-Adjacent-Increasing-Subarrays/"/>
    <id>https://miralemzhang.github.io/2025/10/15/LeetCode-3350-One-Pass-Adjacent-Increasing-Subarrays/</id>
    <published>2025-10-14T16:00:00.000Z</published>
    <updated>2025-12-30T10:32:06.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/lc3350.png"></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>Given an integer array <code>nums</code>, find the maximum length <code>k</code> such that there exist two <strong>adjacent</strong> (non-overlapping) subarrays of length <code>k</code>, and both subarrays are strictly increasing.</p><p>Return the maximum possible value of <code>k</code>. If no such subarrays exist, return <code>1</code>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,5,7,8,9,2,3,4,3,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The subarrays [2,5,7] and [8,9,2] are not valid.</span><br><span class="line">But [5,7,8] and [9,2,3] are not adjacent.</span><br><span class="line">The valid answer is [2,5,7] (length 3) adjacent to... wait, let me recalculate.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The entire array is strictly increasing with length 5.</span><br><span class="line">We can split it into [1,2] and [3,4], giving us k=2.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,2,3,4,3,4,5]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [1,2,3] and [2,3,4] are adjacent strictly increasing subarrays.</span><br><span class="line">We can pick k=2 from both.</span><br></pre></td></tr></table></figure><hr><h2 id="My-Unique-Approach"><a href="#My-Unique-Approach" class="headerlink" title="My Unique Approach"></a>My Unique Approach</h2><p>Instead of using complex data structures or multiple passes, I developed an <strong>elegant single-pass solution</strong> that tracks consecutive increasing segments and intelligently compares them at boundaries.</p><h3 id="Key-Insight"><a href="#Key-Insight" class="headerlink" title="Key Insight"></a>Key Insight</h3><p>The core idea is to recognize that at any point where an increasing sequence breaks, we have <strong>two opportunities</strong> to maximize <code>k</code>:</p><ol><li><strong>Split Strategy</strong>: Divide the current increasing subarray in half</li><li><strong>Adjacent Strategy</strong>: Pair the previous increasing subarray with the current one</li></ol><p>By tracking both the current and previous subarray lengths, we can evaluate both strategies in <strong>O(1) time</strong> at each boundary.</p><hr><h2 id="Algorithm-Logic"><a href="#Algorithm-Logic" class="headerlink" title="Algorithm Logic"></a>Algorithm Logic</h2><h3 id="The-Tracking-Mechanism"><a href="#The-Tracking-Mechanism" class="headerlink" title="The Tracking Mechanism"></a>The Tracking Mechanism</h3><p>I maintain three critical variables:</p><ul><li><code>count</code>: Length of the current strictly increasing subarray</li><li><code>lastcount</code>: Length of the previous strictly increasing subarray</li><li><code>maxm</code>: The maximum <code>k</code> found so far</li></ul><h3 id="The-Decision-Points"><a href="#The-Decision-Points" class="headerlink" title="The Decision Points"></a>The Decision Points</h3><p>At each position where <code>nums[i] &gt;= nums[i+1]</code> (a break in the increasing sequence), we:</p><ol><li>Compare <code>lastcount</code> and <code>count</code> (adjacent strategy)</li><li>Consider <code>count // 2</code> (split current subarray)</li><li>Update our maximum accordingly</li></ol><h3 id="Edge-Case-Handling"><a href="#Edge-Case-Handling" class="headerlink" title="Edge Case Handling"></a>Edge Case Handling</h3><ul><li><strong>Two-element arrays</strong>: Always return 1</li><li><strong>Fully increasing arrays</strong>: Return <code>len(nums) // 2</code></li><li><strong>Final subarray</strong>: Must be checked after the loop ends</li></ul><hr><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxIncreasingSubarrays</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Edge case: minimum possible input</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        count = <span class="number">1</span>          <span class="comment"># Current increasing subarray length</span></span><br><span class="line">        lastcount = <span class="number">0</span>      <span class="comment"># Previous increasing subarray length</span></span><br><span class="line">        maxm = <span class="number">0</span>           <span class="comment"># Maximum k found</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Single pass through the array</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># Continue the increasing sequence</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Break point: evaluate both strategies</span></span><br><span class="line">                <span class="comment"># 1. Adjacent strategy: min(lastcount, count)</span></span><br><span class="line">                <span class="comment"># 2. Split strategy: count // 2</span></span><br><span class="line">                maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(count, lastcount), count // <span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Shift: current becomes previous</span></span><br><span class="line">                lastcount = count</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Don&#x27;t forget the final subarray!</span></span><br><span class="line">        <span class="keyword">if</span> lastcount &gt; <span class="number">0</span>:</span><br><span class="line">            maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lastcount, count), count // <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Special case: entire array is strictly increasing</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> count // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># If no valid pair found, minimum is always 1</span></span><br><span class="line">        <span class="keyword">return</span> maxm <span class="keyword">if</span> maxm != <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h2><p>Let me walk you through each critical part of my solution:</p><h3 id="Step-1-Edge-Case-Two-Elements"><a href="#Step-1-Edge-Case-Two-Elements" class="headerlink" title="Step 1: Edge Case - Two Elements"></a>Step 1: Edge Case - Two Elements</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>For the smallest possible input, we can only have two subarrays of length 1, so return 1 immediately.</p><h3 id="Step-2-The-Core-Loop-Tracking-Increases"><a href="#Step-2-The-Core-Loop-Tracking-Increases" class="headerlink" title="Step 2: The Core Loop - Tracking Increases"></a>Step 2: The Core Loop - Tracking Increases</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>As we iterate, we simply count consecutive strictly increasing elements. This gives us the length of the current increasing subarray.</p><h3 id="Step-3-Boundary-Analysis-The-Magic-Happens-Here"><a href="#Step-3-Boundary-Analysis-The-Magic-Happens-Here" class="headerlink" title="Step 3: Boundary Analysis - The Magic Happens Here"></a>Step 3: Boundary Analysis - The Magic Happens Here</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(count, lastcount), count // <span class="number">2</span>)</span><br><span class="line">    lastcount = count</span><br><span class="line">    count = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>When we hit a boundary (increasing sequence breaks), we:</p><ol><li><p><strong>Compare three values</strong>:</p><ul><li>Current maximum: <code>maxm</code></li><li>Adjacent strategy: <code>min(count, lastcount)</code> - take the smaller of the two adjacent subarrays</li><li>Split strategy: <code>count // 2</code> - split the current subarray in half</li></ul></li><li><p><strong>Update tracking</strong>: Move current to previous, reset current to 1</p></li></ol><h3 id="Step-4-Final-Subarray-Check"><a href="#Step-4-Final-Subarray-Check" class="headerlink" title="Step 4: Final Subarray Check"></a>Step 4: Final Subarray Check</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> lastcount &gt; <span class="number">0</span>:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lastcount, count), count // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>After the loop, we still have the final increasing subarray to consider. We must check it against the previous one using the same logic.</p><h3 id="Step-5-Fully-Increasing-Array"><a href="#Step-5-Fully-Increasing-Array" class="headerlink" title="Step 5: Fully Increasing Array"></a>Step 5: Fully Increasing Array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> count == <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="keyword">return</span> count // <span class="number">2</span></span><br></pre></td></tr></table></figure><p>If the entire array is strictly increasing (no breaks occurred), the optimal solution is to split it in half.</p><hr><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><h3 id="Time-Complexity-O-n"><a href="#Time-Complexity-O-n" class="headerlink" title="Time Complexity: O(n)"></a>Time Complexity: <strong>O(n)</strong></h3><p>We iterate through the array exactly once, performing constant-time operations at each step:</p><ul><li>Comparison: O(1)</li><li>Counter updates: O(1)</li><li>Max calculations: O(1)</li></ul><p><strong>Total</strong>: Single pass â†’ O(n)</p><h3 id="Space-Complexity-O-1"><a href="#Space-Complexity-O-1" class="headerlink" title="Space Complexity: O(1)"></a>Space Complexity: <strong>O(1)</strong></h3><p>We only use three integer variables regardless of input size:</p><ul><li><code>count</code></li><li><code>lastcount</code></li><li><code>maxm</code></li></ul><p>No additional data structures needed!</p><hr><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>The problem essentially asks: <strong>Whatâ€™s the maximum k such that we can find two adjacent strictly increasing subarrays of length k?</strong></p><p>My approach recognizes that:</p><ol><li><p><strong>Any strictly increasing subarray of length L can be split into two adjacent subarrays of length L&#x2F;2</strong></p><ul><li>Example: <code>[1,2,3,4]</code> â†’ <code>[1,2]</code> and <code>[3,4]</code></li></ul></li><li><p><strong>Two adjacent strictly increasing subarrays of lengths A and B can form two subarrays of length min(A,B)</strong></p><ul><li>Example: <code>[1,2,3]</code> (length 3) and <code>[5,6]</code> (length 2) â†’ k &#x3D; 2</li></ul></li><li><p><strong>At any boundary, we choose the better strategy</strong></p><ul><li>Split current: <code>count // 2</code></li><li>Use adjacent: <code>min(count, lastcount)</code></li></ul></li></ol><h3 id="The-Greedy-Choice"><a href="#The-Greedy-Choice" class="headerlink" title="The Greedy Choice"></a>The Greedy Choice</h3><p>This solution is <strong>greedy</strong> in nature - at each decision point, we choose the maximum possible value. This works because:</p><ul><li>Once we pass a boundary, the previous subarray length is fixed</li><li>We canâ€™t â€œgo backâ€ and change it</li><li>Therefore, making the locally optimal choice (max of the three options) is globally optimal</li></ul><hr><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><p>Letâ€™s trace through some examples to see the algorithm in action:</p><h3 id="Example-1-nums-2-5-7-8-9-2-3-4-3-1"><a href="#Example-1-nums-2-5-7-8-9-2-3-4-3-1" class="headerlink" title="Example 1: nums &#x3D; [2,5,7,8,9,2,3,4,3,1]"></a>Example 1: nums &#x3D; [2,5,7,8,9,2,3,4,3,1]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 2&lt;5 â†’ count=2</span><br><span class="line">i=1: 5&lt;7 â†’ count=3</span><br><span class="line">i=2: 7&lt;8 â†’ count=4</span><br><span class="line">i=3: 8&lt;9 â†’ count=5</span><br><span class="line">i=4: 9â‰¥2 â†’ Break!</span><br><span class="line">     maxm = max(0, min(5,0), 5//2) = max(0, 0, 2) = 2</span><br><span class="line">     lastcount=5, count=1</span><br><span class="line"></span><br><span class="line">i=5: 2&lt;3 â†’ count=2</span><br><span class="line">i=6: 3&lt;4 â†’ count=3</span><br><span class="line">i=7: 4â‰¥3 â†’ Break!</span><br><span class="line">     maxm = max(2, min(3,5), 3//2) = max(2, 3, 1) = 3</span><br><span class="line">     lastcount=3, count=1</span><br><span class="line"></span><br><span class="line">i=8: 3â‰¥1 â†’ Break!</span><br><span class="line">     maxm = max(3, min(1,3), 1//2) = max(3, 1, 0) = 3</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">Final check:</span><br><span class="line">     maxm = max(3, min(1,1), 1//2) = max(3, 1, 0) = 3</span><br><span class="line"></span><br><span class="line">Output: 3 âœ“</span><br></pre></td></tr></table></figure><h3 id="Example-2-nums-1-2-3-4-5"><a href="#Example-2-nums-1-2-3-4-5" class="headerlink" title="Example 2: nums &#x3D; [1,2,3,4,5]"></a>Example 2: nums &#x3D; [1,2,3,4,5]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 1&lt;2 â†’ count=2</span><br><span class="line">i=1: 2&lt;3 â†’ count=3</span><br><span class="line">i=2: 3&lt;4 â†’ count=4</span><br><span class="line">i=3: 4&lt;5 â†’ count=5</span><br><span class="line"></span><br><span class="line">No breaks occurred!</span><br><span class="line"></span><br><span class="line">count == len(nums) â†’ return 5//2 = 2</span><br><span class="line"></span><br><span class="line">Output: 2 âœ“</span><br></pre></td></tr></table></figure><h3 id="Example-3-nums-5-4-3-2-1"><a href="#Example-3-nums-5-4-3-2-1" class="headerlink" title="Example 3: nums &#x3D; [5,4,3,2,1]"></a>Example 3: nums &#x3D; [5,4,3,2,1]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 5â‰¥4 â†’ Break!</span><br><span class="line">     maxm = max(0, min(1,0), 1//2) = max(0, 0, 0) = 0</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">i=1: 4â‰¥3 â†’ Break!</span><br><span class="line">     maxm = max(0, min(1,1), 1//2) = max(0, 1, 0) = 1</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">... (continues with all breaks)</span><br><span class="line"></span><br><span class="line">Final: maxm = 1</span><br><span class="line"></span><br><span class="line">Output: 1 âœ“</span><br></pre></td></tr></table></figure><hr><h2 id="Comparison-with-Alternative-Approaches"><a href="#Comparison-with-Alternative-Approaches" class="headerlink" title="Comparison with Alternative Approaches"></a>Comparison with Alternative Approaches</h2><h3 id="Approach-1-Two-Pass-Solution"><a href="#Approach-1-Two-Pass-Solution" class="headerlink" title="Approach 1: Two-Pass Solution"></a>Approach 1: Two-Pass Solution</h3><p><strong>Idea</strong>: First pass records all increasing subarray lengths, second pass finds maximum k.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First pass: record lengths</span></span><br><span class="line">lengths = []</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lengths.append(count)</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">lengths.append(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Second pass: find max k</span></span><br><span class="line">maxm = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lengths)-<span class="number">1</span>):</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lengths[i], lengths[i+<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> length <span class="keyword">in</span> lengths:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, length // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>Drawback</strong>: </p><ul><li>Time: Still O(n) but <strong>two passes</strong></li><li>Space: <strong>O(n)</strong> for the lengths array</li><li>Less elegant code</li></ul><h3 id="Approach-2-Dynamic-Programming"><a href="#Approach-2-Dynamic-Programming" class="headerlink" title="Approach 2: Dynamic Programming"></a>Approach 2: Dynamic Programming</h3><p><strong>Idea</strong>: Track increasing lengths in a DP array.</p><p><strong>Drawback</strong>:</p><ul><li>Overcomplicated for this problem</li><li><strong>O(n) space</strong> required</li><li>No performance benefit</li></ul><h3 id="Why-My-Approach-is-Better"><a href="#Why-My-Approach-is-Better" class="headerlink" title="Why My Approach is Better"></a>Why My Approach is Better</h3><table><thead><tr><th>Metric</th><th>My Solution</th><th>Two-Pass</th><th>DP</th></tr></thead><tbody><tr><td><strong>Time</strong></td><td>O(n) - 1 pass</td><td>O(n) - 2 passes</td><td>O(n)</td></tr><tr><td><strong>Space</strong></td><td><strong>O(1)</strong></td><td>O(n)</td><td>O(n)</td></tr></tbody></table><hr><h2 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h2><h3 id="Algorithm-Design-Insights"><a href="#Algorithm-Design-Insights" class="headerlink" title="Algorithm Design Insights"></a>Algorithm Design Insights</h3><ol><li><p><strong>Greedy works when future doesnâ€™t affect past</strong>: Since weâ€™re moving forward and canâ€™t change previous subarrays, greedy choices are safe.</p></li><li><p><strong>Track minimal state</strong>: We only need to remember the previous subarray length, not all previous subarrays.</p></li><li><p><strong>Boundary analysis is powerful</strong>: The break points give us natural decision points.</p></li></ol><h3 id="Coding-Best-Practices"><a href="#Coding-Best-Practices" class="headerlink" title="Coding Best Practices"></a>Coding Best Practices</h3><ol><li><p><strong>Handle edge cases first</strong>: The <code>len(nums)==2</code> check simplifies the main logic.</p></li><li><p><strong>Donâ€™t forget the final element</strong>: After loops, always check if thereâ€™s remaining data to process.</p></li><li><p><strong>Use meaningful variable names</strong>: <code>count</code>, <code>lastcount</code>, <code>maxm</code> clearly indicate their purpose.</p></li></ol><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This single-pass tracking solution demonstrates that many problems have elegant solutions when you:</p><ol><li><strong>Identify the key decision points</strong> (boundaries between increasing subarrays)</li><li><strong>Track minimal necessary state</strong> (current and previous lengths)</li><li><strong>Apply greedy logic at each decision point</strong> (maximize k locally)</li></ol><p>The beauty of this approach lies in its simplicity - we achieve optimal time and space complexity with clear, maintainable code.</p><hr><p><em>Tutorial texts partly co-generated by Claude-4-Sonnet.</em></p><p>Hope this detailed walkthrough helps you understand my efficient approach to this problem! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! ğŸš€</em></p>]]></content>
    
    
    <summary type="html">A one-pass greedy O(n) time O(1) space solution for LeetCode 3350: Maximum Length of Adjacent Increasing Subarrays.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2749 - Minimum Operations to Make Integer Zero</title>
    <link href="https://miralemzhang.github.io/2025/09/05/LeetCode-2749-Solution-Minimum-Operations-to-Make-Integer-Zero/"/>
    <id>https://miralemzhang.github.io/2025/09/05/LeetCode-2749-Solution-Minimum-Operations-to-Make-Integer-Zero/</id>
    <published>2025-09-05T09:42:09.000Z</published>
    <updated>2025-10-15T09:41:41.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>You are given two integers <code>num1</code> and <code>num2</code>. In one operation, you can choose integer <code>i</code> and subtract <code>2^i + num2</code> from <code>num1</code>.</p><p>Return the minimum number of operations to make <code>num1</code> equal to <code>0</code>. If it is impossible to make <code>num1</code> equal to <code>0</code>, return <code>-1</code>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = 3, num2 = -2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can apply the following operations:</span><br><span class="line">- Operation 1: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 3 - 2 = 1.</span><br><span class="line">- Operation 2: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 1 - 2 = -1.</span><br><span class="line">- Operation 3: i = 0, subtract 2^0 + (-2) = 1 - 2 = -1. Now num1 = -1 - (-1) = 0.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = 5, num2 = 7</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: It is impossible to make num1 equal to 0.</span><br></pre></td></tr></table></figure><h2 id="My-Unique-Approach"><a href="#My-Unique-Approach" class="headerlink" title="My Unique Approach"></a>My Unique Approach</h2><p>Instead of the traditional mathematical modeling approach, I developed an <strong>iterative simulation method</strong> that directly mimics the operation process:</p><h3 id="Key-Insight"><a href="#Key-Insight" class="headerlink" title="Key Insight"></a>Key Insight</h3><p>The core idea is to simulate the process step by step:</p><ol><li>For each potential number of operations <code>k</code>, subtract <code>num2</code> from <code>num1</code> </li><li>Check if the remaining value can be represented as a sum of exactly <code>k</code> powers of 2</li><li>Use binary representation to count the minimum number of powers of 2 needed</li></ol><h3 id="Algorithm-Logic"><a href="#Algorithm-Logic" class="headerlink" title="Algorithm Logic"></a>Algorithm Logic</h3><ol><li><strong>Early termination</strong>: If <code>num2 &gt;= num1</code>, return -1 (impossible case)</li><li><strong>Iterative checking</strong>: For each <code>k</code> starting from 1:<ul><li>Calculate <code>current = num1 - k * num2</code></li><li>Count the number of 1â€™s in binary representation of <code>current</code></li><li>If <code>k &gt;= count_of_ones</code>, we can potentially use <code>k</code> operations</li></ul></li><li><strong>Validation</strong>: Ensure the solution is mathematically valid</li></ol><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">makeTheIntegerZero</span>(<span class="params">self, num1, num2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num1: int</span></span><br><span class="line"><span class="string">        :type num2: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Early termination: if num2 &gt;= num1, impossible to reach 0</span></span><br><span class="line">        <span class="keyword">if</span> num2 &gt;= num1:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            ini = num1  <span class="comment"># Store original num1 for validation</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># Simulate subtracting num2 for k operations</span></span><br><span class="line">                num1 -= num2</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Convert to binary and count 1&#x27;s</span></span><br><span class="line">                bin1 = <span class="built_in">bin</span>(num1)[<span class="number">2</span>:]</span><br><span class="line">                count1 = bin1.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Check if we can use k operations</span></span><br><span class="line">                <span class="keyword">if</span> k &gt;= count1:</span><br><span class="line">                    <span class="comment"># Validation checks</span></span><br><span class="line">                    <span class="keyword">if</span> ini &gt; k * num2:</span><br><span class="line">                        <span class="keyword">if</span> ini - k * num2 &lt; k:</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                        <span class="keyword">return</span> k</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># Need more operations</span></span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                    bin1 = <span class="number">0</span></span><br><span class="line">                    count1 = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h3><p>Let me explain each part of my unique approach:</p><h4 id="Step-1-Early-Termination"><a href="#Step-1-Early-Termination" class="headerlink" title="Step 1: Early Termination"></a>Step 1: Early Termination</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> num2 &gt;= num1:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>If <code>num2</code> is greater than or equal to <code>num1</code>, itâ€™s impossible to make <code>num1</code> zero because each operation adds at least <code>num2</code> to the subtraction.</p><h4 id="Step-2-Iterative-Simulation"><a href="#Step-2-Iterative-Simulation" class="headerlink" title="Step 2: Iterative Simulation"></a>Step 2: Iterative Simulation</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">1</span></span><br><span class="line">ini = num1  <span class="comment"># Store original value</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num1 -= num2  <span class="comment"># Simulate the num2 part of each operation</span></span><br></pre></td></tr></table></figure><p>Instead of calculating <code>target = num1 - k * num2</code> directly, I simulate the process by subtracting <code>num2</code> in each iteration.</p><h4 id="Step-3-Binary-Analysis"><a href="#Step-3-Binary-Analysis" class="headerlink" title="Step 3: Binary Analysis"></a>Step 3: Binary Analysis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin1 = <span class="built_in">bin</span>(num1)[<span class="number">2</span>:]</span><br><span class="line">count1 = bin1.count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>For the current value, count how many 1â€™s are in its binary representation. This tells us the minimum number of powers of 2 needed.</p><h4 id="Step-4-Feasibility-Check"><a href="#Step-4-Feasibility-Check" class="headerlink" title="Step 4: Feasibility Check"></a>Step 4: Feasibility Check</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k &gt;= count1:</span><br><span class="line">    <span class="comment"># We have enough operations to represent the number</span></span><br><span class="line">    <span class="keyword">if</span> ini &gt; k * num2:</span><br><span class="line">        <span class="keyword">if</span> ini - k * num2 &lt; k:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><p>The key insight: if we have <code>k</code> operations and only need <code>count1</code> powers of 2, we can use the extra operations by â€œsplittingâ€ larger powers of 2.</p><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><ul><li><strong>Time Complexity</strong>: O(log(num1)), as we iterate at most log(num1) times</li><li><strong>Space Complexity</strong>: O(1), using only constant extra space</li></ul><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>My iterative approach is essentially equivalent to the mathematical formula:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num1 - kÃ—num2 = 2^iâ‚ + 2^iâ‚‚ + ... + 2^iâ‚–</span><br></pre></td></tr></table></figure><p>But instead of calculating <code>num1 - kÃ—num2</code> directly, I simulate it step by step:</p><ul><li>Start with <code>k = 1</code></li><li>Subtract <code>num2</code> from <code>num1</code> (simulating one operation)</li><li>Check if the result can be represented with <code>k</code> powers of 2</li><li>If not, increment <code>k</code> and repeat</li></ul><h3 id="Validation-Logic-Explained"><a href="#Validation-Logic-Explained" class="headerlink" title="Validation Logic Explained"></a>Validation Logic Explained</h3><p>The nested conditions in my code serve important purposes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ini &gt; k * num2:  <span class="comment"># Ensure we haven&#x27;t subtracted too much</span></span><br><span class="line">    <span class="keyword">if</span> ini - k * num2 &lt; k:  <span class="comment"># Ensure target &gt;= k (necessary condition)</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><p>This ensures that:</p><ol><li>The total subtraction <code>k * num2</code> doesnâ€™t exceed the original <code>num1</code></li><li>The remaining value <code>ini - k * num2</code> is at least <code>k</code> (since each power of 2 is at least 1)</li></ol><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><p>Letâ€™s trace through some examples using my approach:</p><h3 id="Example-1-num1-11-num2-1"><a href="#Example-1-num1-11-num2-1" class="headerlink" title="Example 1: num1 &#x3D; 11, num2 &#x3D; 1"></a>Example 1: num1 &#x3D; 11, num2 &#x3D; 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Initial: num1 = 11, num2 = 1, ini = 11</span><br><span class="line"></span><br><span class="line">k = 1:</span><br><span class="line">- num1 = 11 - 1 = 10</span><br><span class="line">- bin(10) = &quot;1010&quot;, count = 2</span><br><span class="line">- k (1) &lt; count (2), so increment k</span><br><span class="line"></span><br><span class="line">k = 2:</span><br><span class="line">- num1 = 10 - 1 = 9  </span><br><span class="line">- bin(9) = &quot;1001&quot;, count = 2</span><br><span class="line">- k (2) &gt;= count (2) âœ“</span><br><span class="line">- ini (11) &gt; k*num2 (2) âœ“</span><br><span class="line">- ini - k*num2 = 9 &gt;= k (2) âœ“</span><br><span class="line">- Return 2</span><br></pre></td></tr></table></figure><h3 id="Example-2-num1-5-num2-7"><a href="#Example-2-num1-5-num2-7" class="headerlink" title="Example 2: num1 &#x3D; 5, num2 &#x3D; 7"></a>Example 2: num1 &#x3D; 5, num2 &#x3D; 7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Initial: num1 = 5, num2 = 7</span><br><span class="line"></span><br><span class="line">Early termination: num2 (7) &gt;= num1 (5)</span><br><span class="line">Return -1</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This iterative simulation approach provides a unique perspective on solving LeetCode 2749. While the mathematical modeling approach is more direct, my method offers better intuition about whatâ€™s actually happening in each operation.</p><p>The key insight is that we can separate the problem into:</p><ol><li>The <code>num2</code> component (handled by iteration)</li><li>The powers of 2 component (handled by binary analysis)</li></ol><p>This separation makes the solution both understandable and efficient.</p><hr><p><em>Tutorial texts partly co-generated by Claude-4-Sonnet.</em></p><p>Hope this analysis helps you understand my unique approach to LeetCode 2749! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! ğŸš€</em></p>]]></content>
    
    
    <summary type="html">An O(n) greedy one-pass solution for LeetCode 2749: Minimum Operations to Make Integer Zero.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>The Path of Revelation (å•Ÿç¤ºè·¯) -- Walk a life, on water and Bewater</title>
    <link href="https://miralemzhang.github.io/2025/09/05/My-First-Blog-Post/"/>
    <id>https://miralemzhang.github.io/2025/09/05/My-First-Blog-Post/</id>
    <published>2025-09-05T09:10:45.000Z</published>
    <updated>2025-10-15T09:42:45.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote style="border: none !important; border-left: none !important; background-color:rgb(36, 39, 43); padding: 10px; margin: 20px 0; border-radius: 8px; color: #ffffff;"><em><span style="font-size: 1.2em; color: #ffffff;">Write the things which thou hast seen, and the things which are, and the things which shall be hereafter.</span></em><br><em style="color: #ffffff;">æ‰€ä»¥ä½ è¦æŠŠæ‰€å·²çœ‹è¦‹çš„äº‹ï¼ŒåŠä»¥ç¾åœ¨çš„äº‹ï¼Œä¸¦å°‡ä¾†å¿…æˆçš„äº‹ï¼Œéƒ½è¨˜å¯«å‡ºä¾†ã€‚</em><div style="text-align: right; margin-top: 10px; font-size: 1em; color: #888;">â€” Revelation 1:19<br></div></blockquote>]]></content>
    
    
    <summary type="html">æ‰€ä»¥ä½ è¦æŠŠæ‰€å·²çœ‹è¦‹çš„äº‹ï¼ŒåŠä»¥ç¾åœ¨çš„äº‹ï¼Œä¸¦å°‡ä¾†å¿…æˆçš„äº‹ï¼Œéƒ½è¨˜å¯«å‡ºä¾†ã€‚</summary>
    
    
    
    <category term="Thoughts" scheme="https://miralemzhang.github.io/categories/Thoughts/"/>
    
    
    <category term="Book&amp;Music Review" scheme="https://miralemzhang.github.io/tags/Book-Music-Review/"/>
    
  </entry>
  
</feed>
