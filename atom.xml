<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MLMZZZOOO&#39;s Blog</title>
  
  <subtitle>discover the world and share my thoughts</subtitle>
  <link href="https://miralemzhang.github.io/atom.xml" rel="self"/>
  
  <link href="https://miralemzhang.github.io/"/>
  <updated>2025-12-31T09:29:26.793Z</updated>
  <id>https://miralemzhang.github.io/</id>
  
  <author>
    <name>Miralem Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025 Annual -- 我在未来等你</title>
    <link href="https://miralemzhang.github.io/2025/12/24/2025/"/>
    <id>https://miralemzhang.github.io/2025/12/24/2025/</id>
    <published>2025-12-23T17:10:45.000Z</published>
    <updated>2025-12-31T09:29:26.793Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><style>.post-content p {  text-indent: 2em;  margin-bottom: 1.2em;}.post-content blockquote p,.post-content div p {  text-indent: 0;}</style><blockquote style="border: none !important; border-left: none !important; background-color:rgb(36, 39, 43); padding: 10px; margin: 20px 0; border-radius: 8px; color: #ffffff;"><em><span style="font-size: 1em; color: #ffffff;"></span></em><br><em style="color: #ffffff;">L'avenir, tu n'as pas à le prévoir, mais à le permettre... <br>L'amour, une fois qu'il a germé, donne des racines qui ne finissent plus de croître.</em><div style="text-align: right; margin-top: 10px; font-size: 1em; color: #888;"><br>-- Terre des hommes</div></blockquote><br><br>hey miralem,<br><br><p>一年前的你，很难想象到不知不觉能走这么远了吧。我想，一年的最后一天，总要写些什么留下。虽然学了理工科之后早已快丢掉遣词造句的心力，但总归，能看着你一路路走下去，总该要有些地方，你一直能听到我的回音。</p><h2 id="i-le-pelerinage"><a href="#i-le-pelerinage" class="headerlink" title="i. le pèlerinage"></a>i. le pèlerinage</h2><p>wow, where to start. 第一次在博客里用中文打字，一下子就不知道该说些什么了。今年，woo，真是发生了太多事。去了更远地方、见到原来不敢想象能亲眼所及的风景、还坚守着自己，允许自己在宏阔的线性时间观下保有小小的些许正交项……“理想也需生存”的领悟虽不骤然，却也算是应许。之前我常常还会说2024是craziest year，所以去年的今天也一定想不到能拥有这样的东西吧。</p><p>也许会有质疑这作品或者唱词没有情节，但是难道人类的境况就有情节吗？你看，所以我正学着不再为这一年强行安放某种逻辑，或是命出某样“道路”。既然生活本就是一连串随机震颤，那我就只记录那些破碎却闪光的瞬间吧，至少它们都曾照亮过你，照亮着我——这首只有旋律、没有终章的曲子——也不必再像考场般去求证工整的马尔可夫，或许这远征，只要跌跌撞撞，环回真实的自己。</p><p>2024教会了我疯狂，而2025教会了我如何在疯狂的余烬中搭建平静的秩序。或许这就是朝圣的意义——不是非去往 某个 圣地，而不断向前走，“无力者有力”，直到在海鸥群和一片嘈杂中，听得到心跳动的形状。</p><div style="max-width: 470px; margin: 24px 0; border: none !important; border-left: none !important; background-color: #21252b; padding: 14px 18px; border-radius: 10px;">  <span style="display: block; font-size: 0.61em; color: #f2f2f2; margin-bottom:6px;">    "因为无论在什么地点，<br>    在天光覆照的整个人间，<br>    人人说话都各有方式，<br>    我能不用自己语言？"  </span>  <div style="text-align: left; font-size: 0.97em; color: #8aa9d6; margin-top:8px;">    —— 浮士德，3462-3465  </div></div><p>然后有新的心跳，自信说出，我在这里。</p><h2 id="ii-Hinneni"><a href="#ii-Hinneni" class="headerlink" title="ii. Hinneni"></a>ii. Hinneni</h2><p>“J’ai vu la flamme de la liberté faire resplendir les hommes, et la tyrannie les abrutir.”</p><p>已经过了一翻开在路上或者盖茨比就能感动得盈眶的年纪，也真正有机会走近过彼岸那原以为遥不可及的远方。的确，它不够完美，我也知道它应许的不能也不会是属于我真正的山，也不因为那光足够纯净，只是仿佛，从文明的视角看，似乎仅仅因为更熟悉他们眼中洋溢的快乐，心底流淌的自由，但好像这些也足够了，胸无大志的indifference，更能成自己果壳里的君王。这里的你已经遇过太多匪夷所思，见过太多荒谬至极，可你还是选择去相信，去拥抱，去勇敢，只是该在另个维度，只是该去夜尽梦醒。</p><p>因为你在好多年前那些闷热的午后里懵困地学读的语法书真是对的，一个人只有先耕种才能收获，先进行才会完成；先离开，才有归来。</p><p>无论如何，总不会比现在这里还差了。</p><p>于是继续不假思索地上路，因为出发的感觉真是太好了。那刹那世界突然充满了那么那么多可能性。</p><p>所以，这年你会去感恩很多很多。做了可能是人生里最疯狂的决定、去到很远很远的地方、认识新的朋友，习惯为一分一分去搏命、习惯用五个小时的夜晚换不再焦虑到太阳升起的期待，撑出标化、找到实习、动笔文章，一笔一划把你期待的那个未来拼成实感的将与来，继续对抗下去吧，我会让你心安。</p><p>还有一路都能帮助我、相信我、鼓励我的你们。miralem，你得时时刻刻记住多幸运有这么好的大家，好希望没有辜负太多。广州到深圳、美国、香港，无论多远，我会一直一直记住你们的声音，我们会在更大的世界里重逢。</p><h2 id="iii-“euphoria”"><a href="#iii-“euphoria”" class="headerlink" title="iii. “euphoria”"></a>iii. “euphoria”</h2><p>和ZJU-China这座我永远的家。</p><p>喔，一年前因为那个naive得好笑的理由一心只想着去打上比赛的你，不会想到吧。能第一次在“专业之外”去试着探索，第一次真正去学到或者用起那些你能真正说出“喜欢”的知识，第一次坚定下未来的 那个 决定，</p><p>还有最重要的，第一次，认识这么这么好的大家。</p><p>和一夜夜晚，冬夏春秋，我们一笔一划里让这只可爱的小鱼慢慢走近眼前的欣望，永远会是我最珍贵的忆记。</p><p>还有iLUMA，我总会想到安托万笔下王子遇到的点灯人，而他也说，在那很之前的里昂，关于点灯人的描叙是这样的（让我查一下！）“dès le crépuscule, nous illuminassions la planète pour guider les voyageurs….”对呀，好喜欢illuminassions，“我们照亮”，朝着那份使命般沉重与荣光，14颗独一无二的星星汇成最绚煦的明亮，缺去任何，都不会完整。</p><p>更幸运地，也是这光让我有一次次信心去one step more，造出好玩的轮子，修理熄了的曙光，让我每一天都有信心去期待一个更值得大家的自己。</p><p>你看，然后不知不觉，我们就已经能走到这么多、这么远，巴黎的月夜、里昂的晨光，和无数个种种感动的瞬间，多幸运我们能一起奔赴。</p><p>一起分担寒潮、风雷、霹雳；</p><p>共享雾霭、流岚、虹霓。</p><p>未来无边，眼下的段落不过是一次次下一段旅程起点而已。</p><p>是你们让我相信，其实真正重要的不是世事有无如果，而是当在认清本质之后，仍去热爱生活，</p><p>然后骄傲地燃起每一刻眼前，引着我跑，天空没有极限。</p><p>so proud to be part of our journey，与有荣焉。</p><h2 id="iv-未来歌"><a href="#iv-未来歌" class="headerlink" title="iv. 未来歌"></a>iv. 未来歌</h2><p>“当你走到山坡中段的时候，看不到山顶的风景，你只能看到脚下的路，你只能看到身边自己的影子，</p><p>或许就是最想放弃的时候，因为你在犹豫应该要回头，</p><p>还是要继续向上行。”</p><p>你看，我还是这样，一整年都还在找着自己到底想要什么。我会说出口我很痛苦，因为我知道现在我所有所在这些根本远远不够我所想要的，有些事情也不是靠着长大就能有答案。北方灌着刺骨的风，杭州根本就不是人住的地方，这里没有也不会有“自主的温暖”，还得学着去怀疑揣测，身后是紧追不舍的焦恐和怖惧，我却已经可以微笑着想到了那些坐在管槽瓶罐后面颐指气使的“学家”们，他们丝毫不发觉自己的可悲——生活到身体——生活多奇妙啊！</p><p>但我也很快乐，因为我知道那些真正美好不会在辽远的将来，而是在很近的将来，而你能一步步把它变成能捧在手心里的真实。你看，那些你原本没法想象的机会、那些你差点认定就擦身而过的梦想，甚至那个你以为遥不可及的27fall，不是都竟近在眼前了吗。</p><p>“那么，”我总记得你在初中就很喜欢的这些话，就好像你会在那晚下笔时就想到和未来的我说，“那么，仍是要去做你觉得对的事情，去敢爱，去敢恨，敢说，敢做，敢追求……”</p><p>“别去害怕刹那，那些人只能一辈子待着这里而已……你们该有更好的未来。”</p><p>“这些，我怕看不到的，但我知道总有天你有新的旅程，所以别留遗憾吧！……将来的你，一定一定可以看得到。”</p><p>我更幸运，就像纪德还在《窄门》里写出的这句：正由于我抱着与你相见的希望，我才永远永远认为最崎岖的路是最好的路。miralem，去相信吧，你的泪流满面、绝处逢生，和所有所有陪伴你前行或者前行过的大家，都能护我同行而同在，与我进退也共鸣。一个个你造就我，每一个你，汇成我们。</p><p>我不害怕。</p><p>我相信的，再选择，你还是会继续就去向上行的，你从来从来不会允许自己就那样把自己给搞丢。</p><p>我现在就选择继续向上行。</p><p>「未來的歌，祗有故事 無事故。」</p><img src="/img/25_2.jpg" alt="我們終將在無盡的愛與光明中重逢." style="max-width: 70%; display: block; margin: 2em auto;"><h2 id="v-「祝你在亂流下平安」"><a href="#v-「祝你在亂流下平安」" class="headerlink" title="v. 「祝你在亂流下平安」"></a>v. 「祝你在亂流下平安」</h2><p>印象里，小时候，每年圣诞节，从学校出来总要先去一旁早已暖亮起来的教堂。但那些时候，天已经全黑了，冷风更让整个人都僵硬得睁不开眼。不自觉地把外套裹严起来，寒雾漫涌，球场静无一人，只有容女士的塑像和百卅校庆的装潢隐隐伫着。楼梯口黛墙青瓦上缀着几盏凄阑的灯，映出眼前这夜色，仿佛山水画里朦胧的珊影。</p><p>我望过去，分明看到，榕树的驳影里，教堂暖黄色的灯烛仍正穿破着昏暗，从叶隙里晕出一窣窣烁芒，洒满我眼前的光明。想起年末的传统，我走过去，大门前人很多，但也很安静，孩子们笑着拿起气球和糖果，穿起礼服的学生背着书包和琴盒，带着家人一起的老爷爷用粤语轻声讲起旧日的故事，马上就是新年，灯火映在每个人欢欣的面庞。是啊，于这地、在这城，每一个夜晚的闪亮，都有着一个个生动的灵魂和火光，点染在彼此心旁……当然，还有更隐秘的，那是诗人笔弦不辍的火光、孩子们好奇地燃灯续昼的火光、飞行员划破邃空的火光……</p><p>身体慢慢暖起来，我继续走，轻轻拨开身前榕树的须枝，找到了等着我的朋友们，于是一同去。那时候的我们满踌躇着期许和愿望，无论聊起什么、看到什么，都祝福拥有独一的光亮，都梦想找到真正的自己。从礼堂出来，在院子里闲聊着，风拂过我们。聊起冉阿让如果路过这样温暖的地方或许就不会再有接下来的故事，聊起那天兴起从尖东专门过海到中环看过的人潮，几年之前在波士顿边看独立日烟火边读的《火夜》，新的一年要一起去更远的远方……</p><p>于是我看到一个个真实的“我”，一个个大写的“人”。而人，可以而应当，一个个，很美丽。</p><p>但再后来，仿佛加速键般，太多事发生了太多。</p><p>一年年，那种近乎集体无意识的状态还是大声鼓吹我们仍然该抵制的所谓集体伦理，但是我们自己却不知不觉慢慢地被朝着这种伦理前进，因为我们——不知不觉——忘记了人，人是唯一能解释这种拒绝的理由。沉默比聒噪更加可怕，随波逐流的同化无处不在，不能不发醒啊！</p><p>于是，也一年年，你还是像这样坚守着，我看到了，那些理解或不理解你的他们也都看见了。如果我在黎明出发，那么我应该知道为什么我如今还在努力，记住我所看到的。不是也不该去期望“能修筑起最坚固的人间”，也无心去为那张早已被物是人非的杂志所谓“人”论镜像，我只是需要一个简单的信条来提醒自己。</p><p>我应该为人超过个体的首要地位而奋斗，就像普遍性始终该排在特殊性的前面。</p><p>我相信对普遍性的推崇、标榜，并将所有特定的财富与智慧集合在一起，而且它是唯一真正的秩序，同时也是生命的秩序。你看，即使树也是秩序的一部分，尽管它的根和枝是不同的。</p><p>因而我相信对某种权力或地位特殊性的推崇只会带来压迫，因为它是企图建立在以相似性为基础的秩序之上的威权与专制，是所有暴政的雏形。它将本质的统一和部分的认同混淆了，人不是模型与机器，把石头排列成行，建筑不了教堂。因此我应该反对那些想要将独裁的社会方式强加于其它社会方式，将独特的“领袖意志”强加于其他人，将某个特定的国族因地缘而强行凌驾于其他的国族，将一种专横的意识制度强加于其他的意识制度的人。</p><p>我相信强调人的首要地位是唯一有意义的平等和自由的基础。我相信通过个人的自我而表达出来的人的权利的唯一平等性。</p><p>我也相信自由是能投影在未来里每个人追求向上的自由。平等不是认同，自由也不会是个人和人的对抗的放大。我应该反对任何想要借着虚伪的宏大叙事以奴役无论是个人还是由个人组成的集体的自由的人。</p><p>我相信真正的文明将把人为这而做出的牺牲以命名的自由而为之祝福，并作为它最终唯一得统治的基础。自由是给人的第一个礼物，是超越了个人的平庸的：它创造了自主的人。我将反对任何声称我的自由是给平庸致敬，否定“人”，并将个人桎梏于“主义”之内、囚禁在平庸之中的人。</p><p>乱流之中，我应该继续，为了人而战斗，跟他的敌人战斗，同样也同我自己战斗。</p><p>多谢你，我们总还能有这不随波逐流的勇气，也不被大风吹倒，“去生活、去犯错、去跌倒、去胜利……去用生命再创生命”。他们说“人”字这一撇一捺交互总难并举，但即使正交又怎样？哪怕离散又怎样？我们都努力成着这时代的单位向量，有坐标、有权重、有方向，每次再遇的汇点都闪光，就碰撞出整个银河。够不够奇异、有没有共鸣，都不再重要，都会是幸福。</p><p>那就骄傲做大写的人吧。</p><p>其实我不懂怎样看星星，但为你，我会去修理好彼此整片银河。</p><p>“为自由的牺牲祝福，是文明加诸每个我们的准则。”</p><p>从来不必天气多晴朗，巨匠的手不怕骯髒.</p><p>尽是补丁，百孔千疮也可熠光，</p><p>you can hear me now,</p><p>那就 明年见 未来见.</p><p>山顶见！</p><br>sincerely,<div style="text-align: right;"><br>mlmzzzooo<br>31/12/2025<br></div><br><img src="/img/pr2.png" alt="未完結" style="max-width: 65.10%; display: block; margin: 2em auto;"><style>.time-capsule {  max-width: 340px;  margin: 2em auto;  border-radius: 10px;  overflow: hidden;  background:rgb(36, 56, 84);  border: 1px solid #30363d;}.capsule-header {  padding: 14px 16px;  text-align: center;  border-bottom: 1px solid #30363d;}.capsule-header h3 {  margin: 0;  color: #c9d1d9;  font-size: 0.88em;  font-weight: 500;}.capsule-header .subtitle {  color: #484f58;  font-size: 0.7em;  margin-top: 3px;}.capsule-body { padding: 14px 16px; }.countdown-display {  text-align: center;  padding: 10px;  margin-bottom: 12px;  background: #0d1117;  border-radius: 6px;  border: 1px solid #30363d;}.countdown-display .label {  color: #484f58;  font-size: 0.68em;  margin-bottom: 4px;}.countdown-display .time {  color: #8b949e;  font-size: 0.9em;  font-weight: 500;}.capsule-textarea {  width: 100%;  min-height: 70px;  padding: 10px;  border: 1px solid #30363d;  border-radius: 6px;  background: #0d1117;  color:rgb(78, 100, 123);  font-size: 0.8em;  line-height: 1.5;  resize: none;  font-family: inherit;}.capsule-textarea:focus {  outline: none;  border-color: #58a6ff;}.capsule-textarea::placeholder {  color: #484f58;  font-size: 0.95em;}.capsule-actions {  display: flex;  gap: 8px;  margin-top: 10px;}.capsule-btn {  flex: 1;  padding: 7px 12px;  border: none;  border-radius: 6px;  font-size: 0.75em;  cursor: pointer;  transition: all 0.15s;  font-family: inherit;}.capsule-btn.primary {  background:rgb(96, 154, 180);  color: #fff;}.capsule-btn.primary:hover { background: #2ea043; }.capsule-btn.secondary {  background: #21262d;  color: #8b949e;  border: 1px solid #30363d;}.capsule-btn.secondary:hover {  background: #30363d;  color: #c9d1d9;}.capsule-status {  text-align: center;  padding: 6px;  margin-top: 8px;  border-radius: 6px;  font-size: 0.72em;  display: none;}.capsule-status.success {  background: rgba(35,134,54,0.15);  color:rgb(112, 181, 204);  display: block;}.capsule-status.info {  background: #21262d;  color: #8b949e;  display: block;}.saved-message {  background: #0d1117;  border: 1px solid #30363d;  border-radius: 6px;  padding: 10px;  margin-top: 10px;  display: none;}.saved-message.show { display: block; }.saved-message .saved-label {  color: #484f58;  font-size: 0.68em;  margin-bottom: 6px;}.saved-message .saved-content {  color: #8b949e;  font-size: 0.78em;  line-height: 1.5;  white-space: pre-wrap;}.saved-message .saved-date {  color: #484f58;  font-size: 0.65em;  margin-top: 6px;  text-align: right;}</style><br><br><p style="text-align:left; color:#8b949e; margin-bottom:16px;">或许，你也想留下些话给未来的你……</p><div class="time-capsule">  <div class="capsule-header">    <h3>“你是否听见我的声音，我在未来等你。”</h3>    <div class="subtitle">Time Capsule</div>  </div>  <div class="capsule-body">    <div class="countdown-display">      <div class="label">距离 2026.12.31 还有</div>      <div class="time" id="countdown-timer">--- 天</div>    </div>    <textarea class="capsule-textarea" id="capsule-message" placeholder="写下你想对未来的自己说的话吧...（这只会被未来的你看见哦）"></textarea>    <div class="capsule-actions">      <button class="capsule-btn primary" onclick="saveCapsule()">封存</button>      <button class="capsule-btn secondary" onclick="toggleSaved()">查看</button>    </div>    <div class="capsule-status" id="capsule-status"></div>    <div class="saved-message" id="saved-message">      <div class="saved-label">已封存的寄语</div>      <div class="saved-content" id="saved-content"></div>      <div class="saved-date" id="saved-date"></div>    </div>  </div></div><script>(function() {  function updateCountdown() {    const target = new Date('2026-12-31T23:59:59');    const now = new Date();    const diff = target - now;        if (diff <= 0) {      document.getElementById('countdown-timer').textContent = '时间到了！打开看看吧~';      return;    }        const days = Math.floor(diff / (1000 * 60 * 60 * 24));    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));    const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));        document.getElementById('countdown-timer').textContent =       `${days} 天 ${hours} 小时 ${minutes} 分钟`;  }    updateCountdown();  setInterval(updateCountdown, 60000);     const saved = localStorage.getItem('timeCapsule2025');  if (saved) {    const data = JSON.parse(saved);    document.getElementById('capsule-message').value = data.message || '';  }})();function saveCapsule() {  const message = document.getElementById('capsule-message').value.trim();  if (!message) {    showStatus('hey，请先写点什么吧~', 'info');    return;  }    const data = {    message: message,    savedAt: new Date().toISOString(),    savedAtReadable: new Date().toLocaleString('zh-CN')  };    localStorage.setItem('timeCapsule2025', JSON.stringify(data));  showStatus('寄语已封存！等待未来的你来开启...', 'success');    updateSavedDisplay(data);}function showStatus(msg, type) {  const status = document.getElementById('capsule-status');  status.textContent = msg;  status.className = 'capsule-status ' + type;  setTimeout(() => {    status.className = 'capsule-status';  }, 3000);}function toggleSaved() {  const savedDiv = document.getElementById('saved-message');  const saved = localStorage.getItem('timeCapsule2025');    if (!saved) {    showStatus('还没有保存过寄语哦~', 'info');    return;  }    const data = JSON.parse(saved);  updateSavedDisplay(data);  savedDiv.classList.toggle('show');}function updateSavedDisplay(data) {  document.getElementById('saved-content').textContent = data.message;  document.getElementById('saved-date').textContent = '封存于 ' + data.savedAtReadable;}</script>]]></content>
    
    
    <summary type="html">你看，这就是为什么我们一次次奔赴，任何事物都有属于它的光亮.</summary>
    
    
    
    <category term="Thoughts" scheme="https://miralemzhang.github.io/categories/Thoughts/"/>
    
    
    <category term="Annual Review" scheme="https://miralemzhang.github.io/tags/Annual-Review/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 3363 - Find the Maximum Number of Fruits Collected</title>
    <link href="https://miralemzhang.github.io/2025/11/07/LeetCode-3363-Find-Maximum-Number-of-Fruits-Collected/"/>
    <id>https://miralemzhang.github.io/2025/11/07/LeetCode-3363-Find-Maximum-Number-of-Fruits-Collected/</id>
    <published>2025-11-07T13:20:05.000Z</published>
    <updated>2025-12-30T10:33:31.836Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>There is a game dungeon comprised of <code>n x n</code> rooms arranged in a grid.</p><p>You are given a 2D array <code>fruits</code> of size <code>n x n</code>, where <code>fruits[i][j]</code> represents the number of fruits in the room at position <code>(i, j)</code>. Three children will play in the game dungeon, with <strong>initial positions</strong> at the corner rooms <code>(0, 0)</code>, <code>(0, n - 1)</code>, and <code>(n - 1, 0)</code>.</p><p>The children will make <strong>exactly</strong> <code>n - 1</code> moves according to the following rules to reach the room <code>(n - 1, n - 1)</code>:</p><ul><li>The child starting from <code>(0, 0)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i + 1, j + 1)</code>, <code>(i + 1, j)</code>, or <code>(i, j + 1)</code> if the target room exists.</li><li>The child starting from <code>(0, n - 1)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i + 1, j - 1)</code>, <code>(i + 1, j)</code>, or <code>(i + 1, j + 1)</code> if the target room exists.</li><li>The child starting from <code>(n - 1, 0)</code> must move from their current room <code>(i, j)</code> to one of the rooms <code>(i - 1, j + 1)</code>, <code>(i, j + 1)</code>, or <code>(i + 1, j + 1)</code> if the target room exists.</li></ul><p>When a child enters a room, they will collect all the fruits there. If two or more children enter the same room, only one child will collect the fruits, and the room will be emptied after they leave.</p><p>Return the <strong>maximum</strong> number of fruits the children can collect from the dungeon.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: fruits = [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]</span><br><span class="line">Output: 100</span><br><span class="line">Explanation: </span><br><span class="line">- Child 1 (from (0,0)): (0,0) → (1,1) → (2,2) → (3,3)</span><br><span class="line">- Child 2 (from (0,3)): (0,3) → (1,3) → (2,3) → (3,3)</span><br><span class="line">- Child 3 (from (3,0)): (3,0) → (3,1) → (3,2) → (3,3)</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: fruits = [[1,1],[1,1]]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: All children end up at (1,1) collecting all fruits.</span><br></pre></td></tr></table></figure><hr><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><p>When I first encountered this problem, my intuition was that this is a <strong>multi-path dynamic programming problem</strong>. Three children start from different positions simultaneously and must reach the same destination <code>(n-1, n-1)</code> in exactly <code>n-1</code> steps, with the constraint that when multiple children enter the same room, only one can collect the fruits.</p><p>This reminded me of a variant of the classic <strong>“Cherry Pickup”</strong> problem, but with three paths instead of two, which significantly increases the complexity. The key insight is that we need to simultaneously track the position states of all three children and correctly handle fruit collection in overlapping rooms.</p><hr><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>I adopted a <strong>4-dimensional dynamic programming</strong> approach:</p><h3 id="State-Definition"><a href="#State-Definition" class="headerlink" title="State Definition"></a>State Definition</h3><p><code>dp(step, pos_1, pos_2, pos_3)</code> represents the maximum number of fruits that can be collected when the three children are at positions <code>pos_1</code>, <code>pos_2</code>, <code>pos_3</code> respectively at step <code>step</code>.</p><h3 id="Movement-Rules"><a href="#Movement-Rules" class="headerlink" title="Movement Rules"></a>Movement Rules</h3><p>Each child has different movement constraints:</p><ul><li><strong>Child 1</strong> (starting from <code>(0,0)</code>): can move right <code>(i,j+1)</code>, down <code>(i+1,j)</code>, or diagonally down-right <code>(i+1,j+1)</code></li><li><strong>Child 2</strong> (starting from <code>(0,n-1)</code>): can move down-left <code>(i+1,j-1)</code>, down <code>(i+1,j)</code>, or down-right <code>(i+1,j+1)</code></li><li><strong>Child 3</strong> (starting from <code>(n-1,0)</code>): can move up-right <code>(i-1,j+1)</code>, right <code>(i,j+1)</code>, or down-right <code>(i+1,j+1)</code></li></ul><h3 id="State-Transition"><a href="#State-Transition" class="headerlink" title="State Transition"></a>State Transition</h3><p>For each state <code>(step, pos_1, pos_2, pos_3)</code>:</p><ol><li><strong>Calculate current reward</strong>: Sum up fruits at the three children’s current positions, counting overlapping positions only once.</li><li><strong>Try all movement combinations</strong>: Each child chooses their next position according to their movement rules.</li><li><strong>Recursive solution</strong>: Recursively calculate the maximum future reward for each movement combination.</li><li><strong>Take maximum</strong>: Choose the maximum value among all possible combinations.</li></ol><h3 id="Base-Case"><a href="#Base-Case" class="headerlink" title="Base Case"></a>Base Case</h3><p>When <code>step = n-1</code>, check if all three children have reached the target position <code>(n-1, n-1)</code>:</p><ul><li>If all reached: return the fruit count at that position (can only be collected once).</li><li>Otherwise: return <code>-∞</code> to indicate an invalid state.</li></ul><h3 id="Memoization-Optimization"><a href="#Memoization-Optimization" class="headerlink" title="Memoization Optimization"></a>Memoization Optimization</h3><p>Use a dictionary <code>memo</code> to cache computed states and avoid redundant calculations.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">step, pos1, pos2, pos3</span>):</span><br><span class="line">    <span class="comment"># Check cache</span></span><br><span class="line">    <span class="keyword">if</span> (step, pos1, pos2, pos3) <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="keyword">return</span> memo[(step, pos1, pos2, pos3)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Base case</span></span><br><span class="line">    <span class="keyword">if</span> step == n - <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># Check if all reached target position</span></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># Calculate current reward + recursively solve future reward</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># Cache result and return</span></span><br></pre></td></tr></table></figure><hr><h2 id="Key-Insight-Path-Decomposition"><a href="#Key-Insight-Path-Decomposition" class="headerlink" title="Key Insight: Path Decomposition"></a>Key Insight: Path Decomposition</h2><p>A crucial observation simplifies this problem dramatically:</p><ol><li><p><strong>Child 1 is locked to the diagonal</strong>: Due to movement constraints and the requirement to reach <code>(n-1, n-1)</code> in exactly <code>n-1</code> steps, Child 1 <strong>must</strong> follow the main diagonal path <code>(0,0) → (1,1) → ... → (n-1,n-1)</code>.</p></li><li><p><strong>Child 2 stays above the diagonal</strong>: Starting at <code>(0, n-1)</code> and moving downward, Child 2’s valid positions satisfy <code>j ≥ i</code>.</p></li><li><p><strong>Child 3 stays below the diagonal</strong>: Starting at <code>(n-1, 0)</code> and moving rightward, Child 3’s valid positions satisfy <code>i ≥ j</code>.</p></li></ol><p>This means the three paths <strong>naturally don’t overlap</strong> (except at the destination), allowing us to solve three independent subproblems!</p><hr><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxCollectedFruits</span>(<span class="params">self, fruits</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(fruits)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Child 1: Must follow the diagonal path</span></span><br><span class="line">        child1_fruits = <span class="built_in">sum</span>(fruits[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">solve_child2</span>():</span><br><span class="line">            <span class="comment"># DP for child starting from (0, n-1)</span></span><br><span class="line">            dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case: destination reached</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Fill DP table from bottom to top</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> j &lt; i:  <span class="comment"># Invalid: must stay above/on diagonal</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    max_val = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># Try all three moves: down-left, down, down-right</span></span><br><span class="line">                    <span class="keyword">for</span> dj <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">                        ni, nj = i + <span class="number">1</span>, j + dj</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= ni &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= nj &lt; n <span class="keyword">and</span> dp[ni][nj] != -<span class="number">1</span>:</span><br><span class="line">                            <span class="comment"># Don&#x27;t count diagonal cells (Child 1 collects them)</span></span><br><span class="line">                            curr_fruit = <span class="number">0</span> <span class="keyword">if</span> (i == j) <span class="keyword">else</span> fruits[i][j]</span><br><span class="line">                            max_val = <span class="built_in">max</span>(max_val, curr_fruit + dp[ni][nj])</span><br><span class="line">                    </span><br><span class="line">                    dp[i][j] = max_val</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>] <span class="keyword">if</span> dp[<span class="number">0</span>][n-<span class="number">1</span>] != -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">solve_child3</span>():</span><br><span class="line">            <span class="comment"># DP for child starting from (n-1, 0)</span></span><br><span class="line">            dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">            dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case: destination reached</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># Fill DP table from right to left</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> i &lt; j:  <span class="comment"># Invalid: must stay below/on diagonal</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    </span><br><span class="line">                    max_val = -<span class="number">1</span></span><br><span class="line">                    <span class="comment"># Try all three moves: up-right, right, down-right</span></span><br><span class="line">                    <span class="keyword">for</span> di <span class="keyword">in</span> [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]:</span><br><span class="line">                        ni, nj = i + di, j + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= ni &lt; n <span class="keyword">and</span> <span class="number">0</span> &lt;= nj &lt; n <span class="keyword">and</span> dp[ni][nj] != -<span class="number">1</span>:</span><br><span class="line">                            <span class="comment"># Don&#x27;t count diagonal cells (Child 1 collects them)</span></span><br><span class="line">                            curr_fruit = <span class="number">0</span> <span class="keyword">if</span> (i == j) <span class="keyword">else</span> fruits[i][j]</span><br><span class="line">                            max_val = <span class="built_in">max</span>(max_val, curr_fruit + dp[ni][nj])</span><br><span class="line">                    </span><br><span class="line">                    dp[i][j] = max_val</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>] <span class="keyword">if</span> dp[n-<span class="number">1</span>][<span class="number">0</span>] != -<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        child2_fruits = solve_child2()</span><br><span class="line">        child3_fruits = solve_child3()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> child1_fruits + child2_fruits + child3_fruits</span><br></pre></td></tr></table></figure><hr><h2 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h2><p>Let me walk you through each critical part of my solution:</p><h3 id="Step-1-Child-1-Diagonal-Collection"><a href="#Step-1-Child-1-Diagonal-Collection" class="headerlink" title="Step 1: Child 1 - Diagonal Collection"></a>Step 1: Child 1 - Diagonal Collection</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child1_fruits = <span class="built_in">sum</span>(fruits[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br></pre></td></tr></table></figure><p>Child 1 starting from <code>(0, 0)</code> has a critical constraint: each move must go to <code>(i+1, j+1)</code>, <code>(i+1, j)</code>, or <code>(i, j+1)</code>. Given that they must reach <code>(n-1, n-1)</code> in exactly <code>n-1</code> moves, the <strong>only valid path</strong> is the main diagonal! So we simply sum all diagonal elements.</p><h3 id="Step-2-Child-2-Upper-Triangle-DP"><a href="#Step-2-Child-2-Upper-Triangle-DP" class="headerlink" title="Step 2: Child 2 - Upper Triangle DP"></a>Step 2: Child 2 - Upper Triangle DP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve_child2</span>():</span><br><span class="line">    dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case</span></span><br></pre></td></tr></table></figure><p>Key implementation details:</p><ol><li><strong>DP Table Initialization</strong>: Use <code>-1</code> to mark unreachable states</li><li><strong>Base Case</strong>: <code>dp[n-1][n-1] = 0</code> (destination reached, fruits already counted by Child 1)</li><li><strong>Iteration Order</strong>: Bottom-up (from row <code>n-2</code> to <code>0</code>)</li><li><strong>Constraint Check</strong>: <code>j &lt; i</code> means invalid position (crossed diagonal)</li><li><strong>Avoiding Double Count</strong>: <code>curr_fruit = 0 if (i == j)</code> ensures diagonal cells aren’t counted twice</li></ol><h3 id="Step-3-Child-3-Lower-Triangle-DP"><a href="#Step-3-Child-3-Lower-Triangle-DP" class="headerlink" title="Step 3: Child 3 - Lower Triangle DP"></a>Step 3: Child 3 - Lower Triangle DP</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solve_child3</span>():</span><br><span class="line">    dp = [[-<span class="number">1</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    dp[n-<span class="number">1</span>][n-<span class="number">1</span>] = <span class="number">0</span>  <span class="comment"># Base case</span></span><br></pre></td></tr></table></figure><p>Symmetric logic to Child 2:</p><ol><li><strong>Iteration Order</strong>: Right-to-left (from column <code>n-2</code> to <code>0</code>)</li><li><strong>Constraint Check</strong>: <code>i &lt; j</code> means invalid position (crossed diagonal)</li><li><strong>Movement</strong>: Up-right, right, or down-right (column always increases by 1)</li></ol><h3 id="Step-4-Combine-Results"><a href="#Step-4-Combine-Results" class="headerlink" title="Step 4: Combine Results"></a>Step 4: Combine Results</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> child1_fruits + child2_fruits + child3_fruits</span><br></pre></td></tr></table></figure><p>Since paths don’t overlap (diagonal cells handled separately), we simply add the three components.</p><hr><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><h3 id="Time-Complexity-O-n²"><a href="#Time-Complexity-O-n²" class="headerlink" title="Time Complexity: O(n²)"></a>Time Complexity: <strong>O(n²)</strong></h3><ul><li>Child 1 diagonal sum: O(n)</li><li>Child 2 DP: O(n²) states, each with O(1) transitions</li><li>Child 3 DP: O(n²) states, each with O(1) transitions</li></ul><p><strong>Total</strong>: O(n²)</p><h3 id="Space-Complexity-O-n²"><a href="#Space-Complexity-O-n²" class="headerlink" title="Space Complexity: O(n²)"></a>Space Complexity: <strong>O(n²)</strong></h3><ul><li>Child 2 DP table: O(n²)</li><li>Child 3 DP table: O(n²)</li></ul><p><strong>Total</strong>: O(n²)</p><hr><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>The key insight is the <strong>path separation</strong> property:</p><ol><li><p><strong>Child 1 is deterministic</strong>: With <code>n-1</code> moves from <code>(0,0)</code> to <code>(n-1,n-1)</code>, and each move incrementing at least one coordinate, Child 1 must traverse the diagonal. Any deviation would require more or fewer steps.</p></li><li><p><strong>Child 2 stays in upper triangle</strong>: Starting at <code>(0, n-1)</code> with column <code>n-1 &gt; 0 = row</code>, and each move increasing the row by exactly 1, Child 2’s column index is always ≥ row index until reaching the destination.</p></li><li><p><strong>Child 3 stays in lower triangle</strong>: By symmetry, Child 3’s row index is always ≥ column index.</p></li></ol><h3 id="Handling-Overlaps"><a href="#Handling-Overlaps" class="headerlink" title="Handling Overlaps"></a>Handling Overlaps</h3><p>The only possible overlap is on the <strong>diagonal</strong> (where <code>i == j</code>). Since Child 1 always collects diagonal fruits, we set <code>curr_fruit = 0</code> for diagonal positions in Child 2 and Child 3’s DP to avoid double counting.</p><hr><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><h3 id="Example-fruits-1-2-3-4-5-6-8-7-9-10-11-12-13-14-15-16"><a href="#Example-fruits-1-2-3-4-5-6-8-7-9-10-11-12-13-14-15-16" class="headerlink" title="Example: fruits &#x3D; [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]"></a>Example: fruits &#x3D; [[1,2,3,4],[5,6,8,7],[9,10,11,12],[13,14,15,16]]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Grid visualization (n=4):</span><br><span class="line">     0   1   2   3</span><br><span class="line">0  [ 1,  2,  3,  4]  ← Child 2 starts at (0,3)</span><br><span class="line">1  [ 5,  6,  8,  7]</span><br><span class="line">2  [ 9, 10, 11, 12]</span><br><span class="line">3  [13, 14, 15, 16]  ← Child 3 starts at (3,0)</span><br><span class="line">   ↑                     ↘</span><br><span class="line">Child 1              Destination (3,3)</span><br><span class="line">starts (0,0)</span><br><span class="line"></span><br><span class="line">Step 1: Child 1 (diagonal)</span><br><span class="line">Path: (0,0) → (1,1) → (2,2) → (3,3)</span><br><span class="line">Fruits: 1 + 6 + 11 + 16 = 34</span><br><span class="line"></span><br><span class="line">Step 2: Child 2 (upper triangle)</span><br><span class="line">DP fills from bottom-up:</span><br><span class="line">- Row 2: dp[2][3] = 12, dp[2][2] = 0 (diagonal)</span><br><span class="line">- Row 1: dp[1][3] = max(12, 12) + 7 = 19</span><br><span class="line">         dp[1][2] = max(0, 12, 19) + 8 = 27</span><br><span class="line">- Row 0: dp[0][3] = max(27, 19, ?) + 4 = 31</span><br><span class="line">Optimal path: (0,3) → (1,2) → (2,3) → (3,3)</span><br><span class="line">Fruits: 4 + 8 + 12 + 0 = 24</span><br><span class="line"></span><br><span class="line">Step 3: Child 3 (lower triangle)</span><br><span class="line">DP fills from right-to-left:</span><br><span class="line">- Col 2: dp[3][2] = 15, dp[2][2] = 0 (diagonal)</span><br><span class="line">- Col 1: dp[3][1] = max(0, 15, ?) + 14 = 29</span><br><span class="line">- Col 0: dp[3][0] = max(?, 29, ?) + 13 = 42</span><br><span class="line">Optimal path: (3,0) → (3,1) → (3,2) → (3,3)</span><br><span class="line">Fruits: 13 + 14 + 15 + 0 = 42</span><br><span class="line"></span><br><span class="line">Total: 34 + 24 + 42 = 100 ✓</span><br></pre></td></tr></table></figure><hr><h2 id="Comparison-with-Alternative-Approaches"><a href="#Comparison-with-Alternative-Approaches" class="headerlink" title="Comparison with Alternative Approaches"></a>Comparison with Alternative Approaches</h2><h3 id="Approach-1-Full-6D-4D-DP"><a href="#Approach-1-Full-6D-4D-DP" class="headerlink" title="Approach 1: Full 6D&#x2F;4D DP"></a>Approach 1: Full 6D&#x2F;4D DP</h3><p><strong>Idea</strong>: Track all three children’s positions simultaneously</p><p><strong>Drawback</strong>:</p><ul><li>Time: O(n^6) or O(n^4) with optimization</li><li>Space: O(n^6) or O(n^4)</li><li>Extremely complex implementation</li></ul><h3 id="Approach-2-Pure-Memoization-No-Path-Separation"><a href="#Approach-2-Pure-Memoization-No-Path-Separation" class="headerlink" title="Approach 2: Pure Memoization (No Path Separation)"></a>Approach 2: Pure Memoization (No Path Separation)</h3><p><strong>Idea</strong>: Use recursive memoization without recognizing path separation</p><p><strong>Drawback</strong>:</p><ul><li>Still O(n^4) complexity</li><li>Higher constant factor due to recursion overhead</li><li>Less elegant code</li></ul><h3 id="Why-My-Approach-is-Better"><a href="#Why-My-Approach-is-Better" class="headerlink" title="Why My Approach is Better"></a>Why My Approach is Better</h3><table><thead><tr><th>Metric</th><th>My Solution</th><th>6D DP</th><th>Pure Memo</th></tr></thead><tbody><tr><td><strong>Time</strong></td><td>O(n²)</td><td>O(n^6)</td><td>O(n^4)</td></tr><tr><td><strong>Space</strong></td><td>O(n²)</td><td>O(n^6)</td><td>O(n^4)</td></tr><tr><td><strong>Key Insight</strong></td><td>Path separation</td><td>None</td><td>Partial</td></tr></tbody></table><hr><h2 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h2><h3 id="Algorithm-Design-Insights"><a href="#Algorithm-Design-Insights" class="headerlink" title="Algorithm Design Insights"></a>Algorithm Design Insights</h3><ol><li><p><strong>Identify non-overlapping subproblems</strong>: The three paths naturally separate due to movement constraints, allowing independent optimization.</p></li><li><p><strong>Leverage constraints to simplify</strong>: Recognizing that Child 1 must follow the diagonal reduces the problem from 3-path to 2-path optimization.</p></li><li><p><strong>Handle edge cases carefully</strong>: Diagonal cells need special treatment to avoid double counting.</p></li></ol><h3 id="Problem-Solving-Strategy"><a href="#Problem-Solving-Strategy" class="headerlink" title="Problem-Solving Strategy"></a>Problem-Solving Strategy</h3><ol><li><p><strong>Analyze movement constraints</strong>: Understanding each child’s valid region is crucial.</p></li><li><p><strong>Visualize the problem</strong>: Drawing the grid and marking valid regions for each child reveals the separation property.</p></li><li><p><strong>Decompose when possible</strong>: Breaking one 3-path problem into one deterministic path + two independent DP problems dramatically simplifies the solution.</p></li></ol><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This approach demonstrates that careful constraint analysis can transform a seemingly complex multi-agent optimization problem into elegant, tractable subproblems.</p><p>The beauty of this solution lies in recognizing:</p><ol><li><strong>Child 1’s path is deterministic</strong> (must follow diagonal)</li><li><strong>Child 2 and Child 3’s regions are separated</strong> (upper vs. lower triangle)</li><li><strong>Diagonal overlap is the only edge case</strong> (handled by zeroing out)</li></ol><p>By decomposing the problem this way, we achieve <strong>O(n²) time and space</strong> complexity instead of the naive O(n^6) approach—a dramatic improvement that makes the solution practical for large inputs.</p><hr><p><em>Tutorial texts partly co-generated by Claude Opus 4.5.</em></p><p>Hope this detailed walkthrough helps you understand my efficient approach to this problem! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! 🚀</em></p>]]></content>
    
    
    <summary type="html">A memoization approach to the three-path problem: LeetCode 3363 - Find the Maximum Number of Fruits Collected.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 3350 - Track Adjacent Increasing Subarrays</title>
    <link href="https://miralemzhang.github.io/2025/10/15/LeetCode-3350-One-Pass-Adjacent-Increasing-Subarrays/"/>
    <id>https://miralemzhang.github.io/2025/10/15/LeetCode-3350-One-Pass-Adjacent-Increasing-Subarrays/</id>
    <published>2025-10-14T16:00:00.000Z</published>
    <updated>2025-12-30T10:32:06.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/lc3350.png"></p><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>Given an integer array <code>nums</code>, find the maximum length <code>k</code> such that there exist two <strong>adjacent</strong> (non-overlapping) subarrays of length <code>k</code>, and both subarrays are strictly increasing.</p><p>Return the maximum possible value of <code>k</code>. If no such subarrays exist, return <code>1</code>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,5,7,8,9,2,3,4,3,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The subarrays [2,5,7] and [8,9,2] are not valid.</span><br><span class="line">But [5,7,8] and [9,2,3] are not adjacent.</span><br><span class="line">The valid answer is [2,5,7] (length 3) adjacent to... wait, let me recalculate.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The entire array is strictly increasing with length 5.</span><br><span class="line">We can split it into [1,2] and [3,4], giving us k=2.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,2,3,4,3,4,5]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [1,2,3] and [2,3,4] are adjacent strictly increasing subarrays.</span><br><span class="line">We can pick k=2 from both.</span><br></pre></td></tr></table></figure><hr><h2 id="My-Unique-Approach"><a href="#My-Unique-Approach" class="headerlink" title="My Unique Approach"></a>My Unique Approach</h2><p>Instead of using complex data structures or multiple passes, I developed an <strong>elegant single-pass solution</strong> that tracks consecutive increasing segments and intelligently compares them at boundaries.</p><h3 id="Key-Insight"><a href="#Key-Insight" class="headerlink" title="Key Insight"></a>Key Insight</h3><p>The core idea is to recognize that at any point where an increasing sequence breaks, we have <strong>two opportunities</strong> to maximize <code>k</code>:</p><ol><li><strong>Split Strategy</strong>: Divide the current increasing subarray in half</li><li><strong>Adjacent Strategy</strong>: Pair the previous increasing subarray with the current one</li></ol><p>By tracking both the current and previous subarray lengths, we can evaluate both strategies in <strong>O(1) time</strong> at each boundary.</p><hr><h2 id="Algorithm-Logic"><a href="#Algorithm-Logic" class="headerlink" title="Algorithm Logic"></a>Algorithm Logic</h2><h3 id="The-Tracking-Mechanism"><a href="#The-Tracking-Mechanism" class="headerlink" title="The Tracking Mechanism"></a>The Tracking Mechanism</h3><p>I maintain three critical variables:</p><ul><li><code>count</code>: Length of the current strictly increasing subarray</li><li><code>lastcount</code>: Length of the previous strictly increasing subarray</li><li><code>maxm</code>: The maximum <code>k</code> found so far</li></ul><h3 id="The-Decision-Points"><a href="#The-Decision-Points" class="headerlink" title="The Decision Points"></a>The Decision Points</h3><p>At each position where <code>nums[i] &gt;= nums[i+1]</code> (a break in the increasing sequence), we:</p><ol><li>Compare <code>lastcount</code> and <code>count</code> (adjacent strategy)</li><li>Consider <code>count // 2</code> (split current subarray)</li><li>Update our maximum accordingly</li></ol><h3 id="Edge-Case-Handling"><a href="#Edge-Case-Handling" class="headerlink" title="Edge Case Handling"></a>Edge Case Handling</h3><ul><li><strong>Two-element arrays</strong>: Always return 1</li><li><strong>Fully increasing arrays</strong>: Return <code>len(nums) // 2</code></li><li><strong>Final subarray</strong>: Must be checked after the loop ends</li></ul><hr><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxIncreasingSubarrays</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Edge case: minimum possible input</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        count = <span class="number">1</span>          <span class="comment"># Current increasing subarray length</span></span><br><span class="line">        lastcount = <span class="number">0</span>      <span class="comment"># Previous increasing subarray length</span></span><br><span class="line">        maxm = <span class="number">0</span>           <span class="comment"># Maximum k found</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Single pass through the array</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># Continue the increasing sequence</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Break point: evaluate both strategies</span></span><br><span class="line">                <span class="comment"># 1. Adjacent strategy: min(lastcount, count)</span></span><br><span class="line">                <span class="comment"># 2. Split strategy: count // 2</span></span><br><span class="line">                maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(count, lastcount), count // <span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Shift: current becomes previous</span></span><br><span class="line">                lastcount = count</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Don&#x27;t forget the final subarray!</span></span><br><span class="line">        <span class="keyword">if</span> lastcount &gt; <span class="number">0</span>:</span><br><span class="line">            maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lastcount, count), count // <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Special case: entire array is strictly increasing</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> count // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># If no valid pair found, minimum is always 1</span></span><br><span class="line">        <span class="keyword">return</span> maxm <span class="keyword">if</span> maxm != <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h2><p>Let me walk you through each critical part of my solution:</p><h3 id="Step-1-Edge-Case-Two-Elements"><a href="#Step-1-Edge-Case-Two-Elements" class="headerlink" title="Step 1: Edge Case - Two Elements"></a>Step 1: Edge Case - Two Elements</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>For the smallest possible input, we can only have two subarrays of length 1, so return 1 immediately.</p><h3 id="Step-2-The-Core-Loop-Tracking-Increases"><a href="#Step-2-The-Core-Loop-Tracking-Increases" class="headerlink" title="Step 2: The Core Loop - Tracking Increases"></a>Step 2: The Core Loop - Tracking Increases</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>As we iterate, we simply count consecutive strictly increasing elements. This gives us the length of the current increasing subarray.</p><h3 id="Step-3-Boundary-Analysis-The-Magic-Happens-Here"><a href="#Step-3-Boundary-Analysis-The-Magic-Happens-Here" class="headerlink" title="Step 3: Boundary Analysis - The Magic Happens Here"></a>Step 3: Boundary Analysis - The Magic Happens Here</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(count, lastcount), count // <span class="number">2</span>)</span><br><span class="line">    lastcount = count</span><br><span class="line">    count = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>When we hit a boundary (increasing sequence breaks), we:</p><ol><li><p><strong>Compare three values</strong>:</p><ul><li>Current maximum: <code>maxm</code></li><li>Adjacent strategy: <code>min(count, lastcount)</code> - take the smaller of the two adjacent subarrays</li><li>Split strategy: <code>count // 2</code> - split the current subarray in half</li></ul></li><li><p><strong>Update tracking</strong>: Move current to previous, reset current to 1</p></li></ol><h3 id="Step-4-Final-Subarray-Check"><a href="#Step-4-Final-Subarray-Check" class="headerlink" title="Step 4: Final Subarray Check"></a>Step 4: Final Subarray Check</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> lastcount &gt; <span class="number">0</span>:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lastcount, count), count // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>After the loop, we still have the final increasing subarray to consider. We must check it against the previous one using the same logic.</p><h3 id="Step-5-Fully-Increasing-Array"><a href="#Step-5-Fully-Increasing-Array" class="headerlink" title="Step 5: Fully Increasing Array"></a>Step 5: Fully Increasing Array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> count == <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="keyword">return</span> count // <span class="number">2</span></span><br></pre></td></tr></table></figure><p>If the entire array is strictly increasing (no breaks occurred), the optimal solution is to split it in half.</p><hr><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><h3 id="Time-Complexity-O-n"><a href="#Time-Complexity-O-n" class="headerlink" title="Time Complexity: O(n)"></a>Time Complexity: <strong>O(n)</strong></h3><p>We iterate through the array exactly once, performing constant-time operations at each step:</p><ul><li>Comparison: O(1)</li><li>Counter updates: O(1)</li><li>Max calculations: O(1)</li></ul><p><strong>Total</strong>: Single pass → O(n)</p><h3 id="Space-Complexity-O-1"><a href="#Space-Complexity-O-1" class="headerlink" title="Space Complexity: O(1)"></a>Space Complexity: <strong>O(1)</strong></h3><p>We only use three integer variables regardless of input size:</p><ul><li><code>count</code></li><li><code>lastcount</code></li><li><code>maxm</code></li></ul><p>No additional data structures needed!</p><hr><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>The problem essentially asks: <strong>What’s the maximum k such that we can find two adjacent strictly increasing subarrays of length k?</strong></p><p>My approach recognizes that:</p><ol><li><p><strong>Any strictly increasing subarray of length L can be split into two adjacent subarrays of length L&#x2F;2</strong></p><ul><li>Example: <code>[1,2,3,4]</code> → <code>[1,2]</code> and <code>[3,4]</code></li></ul></li><li><p><strong>Two adjacent strictly increasing subarrays of lengths A and B can form two subarrays of length min(A,B)</strong></p><ul><li>Example: <code>[1,2,3]</code> (length 3) and <code>[5,6]</code> (length 2) → k &#x3D; 2</li></ul></li><li><p><strong>At any boundary, we choose the better strategy</strong></p><ul><li>Split current: <code>count // 2</code></li><li>Use adjacent: <code>min(count, lastcount)</code></li></ul></li></ol><h3 id="The-Greedy-Choice"><a href="#The-Greedy-Choice" class="headerlink" title="The Greedy Choice"></a>The Greedy Choice</h3><p>This solution is <strong>greedy</strong> in nature - at each decision point, we choose the maximum possible value. This works because:</p><ul><li>Once we pass a boundary, the previous subarray length is fixed</li><li>We can’t “go back” and change it</li><li>Therefore, making the locally optimal choice (max of the three options) is globally optimal</li></ul><hr><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><p>Let’s trace through some examples to see the algorithm in action:</p><h3 id="Example-1-nums-2-5-7-8-9-2-3-4-3-1"><a href="#Example-1-nums-2-5-7-8-9-2-3-4-3-1" class="headerlink" title="Example 1: nums &#x3D; [2,5,7,8,9,2,3,4,3,1]"></a>Example 1: nums &#x3D; [2,5,7,8,9,2,3,4,3,1]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 2&lt;5 → count=2</span><br><span class="line">i=1: 5&lt;7 → count=3</span><br><span class="line">i=2: 7&lt;8 → count=4</span><br><span class="line">i=3: 8&lt;9 → count=5</span><br><span class="line">i=4: 9≥2 → Break!</span><br><span class="line">     maxm = max(0, min(5,0), 5//2) = max(0, 0, 2) = 2</span><br><span class="line">     lastcount=5, count=1</span><br><span class="line"></span><br><span class="line">i=5: 2&lt;3 → count=2</span><br><span class="line">i=6: 3&lt;4 → count=3</span><br><span class="line">i=7: 4≥3 → Break!</span><br><span class="line">     maxm = max(2, min(3,5), 3//2) = max(2, 3, 1) = 3</span><br><span class="line">     lastcount=3, count=1</span><br><span class="line"></span><br><span class="line">i=8: 3≥1 → Break!</span><br><span class="line">     maxm = max(3, min(1,3), 1//2) = max(3, 1, 0) = 3</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">Final check:</span><br><span class="line">     maxm = max(3, min(1,1), 1//2) = max(3, 1, 0) = 3</span><br><span class="line"></span><br><span class="line">Output: 3 ✓</span><br></pre></td></tr></table></figure><h3 id="Example-2-nums-1-2-3-4-5"><a href="#Example-2-nums-1-2-3-4-5" class="headerlink" title="Example 2: nums &#x3D; [1,2,3,4,5]"></a>Example 2: nums &#x3D; [1,2,3,4,5]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 1&lt;2 → count=2</span><br><span class="line">i=1: 2&lt;3 → count=3</span><br><span class="line">i=2: 3&lt;4 → count=4</span><br><span class="line">i=3: 4&lt;5 → count=5</span><br><span class="line"></span><br><span class="line">No breaks occurred!</span><br><span class="line"></span><br><span class="line">count == len(nums) → return 5//2 = 2</span><br><span class="line"></span><br><span class="line">Output: 2 ✓</span><br></pre></td></tr></table></figure><h3 id="Example-3-nums-5-4-3-2-1"><a href="#Example-3-nums-5-4-3-2-1" class="headerlink" title="Example 3: nums &#x3D; [5,4,3,2,1]"></a>Example 3: nums &#x3D; [5,4,3,2,1]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 5≥4 → Break!</span><br><span class="line">     maxm = max(0, min(1,0), 1//2) = max(0, 0, 0) = 0</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">i=1: 4≥3 → Break!</span><br><span class="line">     maxm = max(0, min(1,1), 1//2) = max(0, 1, 0) = 1</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">... (continues with all breaks)</span><br><span class="line"></span><br><span class="line">Final: maxm = 1</span><br><span class="line"></span><br><span class="line">Output: 1 ✓</span><br></pre></td></tr></table></figure><hr><h2 id="Comparison-with-Alternative-Approaches"><a href="#Comparison-with-Alternative-Approaches" class="headerlink" title="Comparison with Alternative Approaches"></a>Comparison with Alternative Approaches</h2><h3 id="Approach-1-Two-Pass-Solution"><a href="#Approach-1-Two-Pass-Solution" class="headerlink" title="Approach 1: Two-Pass Solution"></a>Approach 1: Two-Pass Solution</h3><p><strong>Idea</strong>: First pass records all increasing subarray lengths, second pass finds maximum k.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First pass: record lengths</span></span><br><span class="line">lengths = []</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lengths.append(count)</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">lengths.append(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Second pass: find max k</span></span><br><span class="line">maxm = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lengths)-<span class="number">1</span>):</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lengths[i], lengths[i+<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> length <span class="keyword">in</span> lengths:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, length // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>Drawback</strong>: </p><ul><li>Time: Still O(n) but <strong>two passes</strong></li><li>Space: <strong>O(n)</strong> for the lengths array</li><li>Less elegant code</li></ul><h3 id="Approach-2-Dynamic-Programming"><a href="#Approach-2-Dynamic-Programming" class="headerlink" title="Approach 2: Dynamic Programming"></a>Approach 2: Dynamic Programming</h3><p><strong>Idea</strong>: Track increasing lengths in a DP array.</p><p><strong>Drawback</strong>:</p><ul><li>Overcomplicated for this problem</li><li><strong>O(n) space</strong> required</li><li>No performance benefit</li></ul><h3 id="Why-My-Approach-is-Better"><a href="#Why-My-Approach-is-Better" class="headerlink" title="Why My Approach is Better"></a>Why My Approach is Better</h3><table><thead><tr><th>Metric</th><th>My Solution</th><th>Two-Pass</th><th>DP</th></tr></thead><tbody><tr><td><strong>Time</strong></td><td>O(n) - 1 pass</td><td>O(n) - 2 passes</td><td>O(n)</td></tr><tr><td><strong>Space</strong></td><td><strong>O(1)</strong></td><td>O(n)</td><td>O(n)</td></tr></tbody></table><hr><h2 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h2><h3 id="Algorithm-Design-Insights"><a href="#Algorithm-Design-Insights" class="headerlink" title="Algorithm Design Insights"></a>Algorithm Design Insights</h3><ol><li><p><strong>Greedy works when future doesn’t affect past</strong>: Since we’re moving forward and can’t change previous subarrays, greedy choices are safe.</p></li><li><p><strong>Track minimal state</strong>: We only need to remember the previous subarray length, not all previous subarrays.</p></li><li><p><strong>Boundary analysis is powerful</strong>: The break points give us natural decision points.</p></li></ol><h3 id="Coding-Best-Practices"><a href="#Coding-Best-Practices" class="headerlink" title="Coding Best Practices"></a>Coding Best Practices</h3><ol><li><p><strong>Handle edge cases first</strong>: The <code>len(nums)==2</code> check simplifies the main logic.</p></li><li><p><strong>Don’t forget the final element</strong>: After loops, always check if there’s remaining data to process.</p></li><li><p><strong>Use meaningful variable names</strong>: <code>count</code>, <code>lastcount</code>, <code>maxm</code> clearly indicate their purpose.</p></li></ol><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This single-pass tracking solution demonstrates that many problems have elegant solutions when you:</p><ol><li><strong>Identify the key decision points</strong> (boundaries between increasing subarrays)</li><li><strong>Track minimal necessary state</strong> (current and previous lengths)</li><li><strong>Apply greedy logic at each decision point</strong> (maximize k locally)</li></ol><p>The beauty of this approach lies in its simplicity - we achieve optimal time and space complexity with clear, maintainable code.</p><hr><p><em>Tutorial texts partly co-generated by Claude-4-Sonnet.</em></p><p>Hope this detailed walkthrough helps you understand my efficient approach to this problem! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! 🚀</em></p>]]></content>
    
    
    <summary type="html">A one-pass greedy O(n) time O(1) space solution for LeetCode 3350: Maximum Length of Adjacent Increasing Subarrays.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2749 - Minimum Operations to Make Integer Zero</title>
    <link href="https://miralemzhang.github.io/2025/09/05/LeetCode-2749-Solution-Minimum-Operations-to-Make-Integer-Zero/"/>
    <id>https://miralemzhang.github.io/2025/09/05/LeetCode-2749-Solution-Minimum-Operations-to-Make-Integer-Zero/</id>
    <published>2025-09-05T09:42:09.000Z</published>
    <updated>2025-10-15T09:41:41.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>You are given two integers <code>num1</code> and <code>num2</code>. In one operation, you can choose integer <code>i</code> and subtract <code>2^i + num2</code> from <code>num1</code>.</p><p>Return the minimum number of operations to make <code>num1</code> equal to <code>0</code>. If it is impossible to make <code>num1</code> equal to <code>0</code>, return <code>-1</code>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = 3, num2 = -2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can apply the following operations:</span><br><span class="line">- Operation 1: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 3 - 2 = 1.</span><br><span class="line">- Operation 2: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 1 - 2 = -1.</span><br><span class="line">- Operation 3: i = 0, subtract 2^0 + (-2) = 1 - 2 = -1. Now num1 = -1 - (-1) = 0.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = 5, num2 = 7</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: It is impossible to make num1 equal to 0.</span><br></pre></td></tr></table></figure><h2 id="My-Unique-Approach"><a href="#My-Unique-Approach" class="headerlink" title="My Unique Approach"></a>My Unique Approach</h2><p>Instead of the traditional mathematical modeling approach, I developed an <strong>iterative simulation method</strong> that directly mimics the operation process:</p><h3 id="Key-Insight"><a href="#Key-Insight" class="headerlink" title="Key Insight"></a>Key Insight</h3><p>The core idea is to simulate the process step by step:</p><ol><li>For each potential number of operations <code>k</code>, subtract <code>num2</code> from <code>num1</code> </li><li>Check if the remaining value can be represented as a sum of exactly <code>k</code> powers of 2</li><li>Use binary representation to count the minimum number of powers of 2 needed</li></ol><h3 id="Algorithm-Logic"><a href="#Algorithm-Logic" class="headerlink" title="Algorithm Logic"></a>Algorithm Logic</h3><ol><li><strong>Early termination</strong>: If <code>num2 &gt;= num1</code>, return -1 (impossible case)</li><li><strong>Iterative checking</strong>: For each <code>k</code> starting from 1:<ul><li>Calculate <code>current = num1 - k * num2</code></li><li>Count the number of 1’s in binary representation of <code>current</code></li><li>If <code>k &gt;= count_of_ones</code>, we can potentially use <code>k</code> operations</li></ul></li><li><strong>Validation</strong>: Ensure the solution is mathematically valid</li></ol><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">makeTheIntegerZero</span>(<span class="params">self, num1, num2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num1: int</span></span><br><span class="line"><span class="string">        :type num2: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Early termination: if num2 &gt;= num1, impossible to reach 0</span></span><br><span class="line">        <span class="keyword">if</span> num2 &gt;= num1:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            ini = num1  <span class="comment"># Store original num1 for validation</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># Simulate subtracting num2 for k operations</span></span><br><span class="line">                num1 -= num2</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Convert to binary and count 1&#x27;s</span></span><br><span class="line">                bin1 = <span class="built_in">bin</span>(num1)[<span class="number">2</span>:]</span><br><span class="line">                count1 = bin1.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Check if we can use k operations</span></span><br><span class="line">                <span class="keyword">if</span> k &gt;= count1:</span><br><span class="line">                    <span class="comment"># Validation checks</span></span><br><span class="line">                    <span class="keyword">if</span> ini &gt; k * num2:</span><br><span class="line">                        <span class="keyword">if</span> ini - k * num2 &lt; k:</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                        <span class="keyword">return</span> k</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># Need more operations</span></span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                    bin1 = <span class="number">0</span></span><br><span class="line">                    count1 = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h3><p>Let me explain each part of my unique approach:</p><h4 id="Step-1-Early-Termination"><a href="#Step-1-Early-Termination" class="headerlink" title="Step 1: Early Termination"></a>Step 1: Early Termination</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> num2 &gt;= num1:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>If <code>num2</code> is greater than or equal to <code>num1</code>, it’s impossible to make <code>num1</code> zero because each operation adds at least <code>num2</code> to the subtraction.</p><h4 id="Step-2-Iterative-Simulation"><a href="#Step-2-Iterative-Simulation" class="headerlink" title="Step 2: Iterative Simulation"></a>Step 2: Iterative Simulation</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">1</span></span><br><span class="line">ini = num1  <span class="comment"># Store original value</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num1 -= num2  <span class="comment"># Simulate the num2 part of each operation</span></span><br></pre></td></tr></table></figure><p>Instead of calculating <code>target = num1 - k * num2</code> directly, I simulate the process by subtracting <code>num2</code> in each iteration.</p><h4 id="Step-3-Binary-Analysis"><a href="#Step-3-Binary-Analysis" class="headerlink" title="Step 3: Binary Analysis"></a>Step 3: Binary Analysis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin1 = <span class="built_in">bin</span>(num1)[<span class="number">2</span>:]</span><br><span class="line">count1 = bin1.count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>For the current value, count how many 1’s are in its binary representation. This tells us the minimum number of powers of 2 needed.</p><h4 id="Step-4-Feasibility-Check"><a href="#Step-4-Feasibility-Check" class="headerlink" title="Step 4: Feasibility Check"></a>Step 4: Feasibility Check</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k &gt;= count1:</span><br><span class="line">    <span class="comment"># We have enough operations to represent the number</span></span><br><span class="line">    <span class="keyword">if</span> ini &gt; k * num2:</span><br><span class="line">        <span class="keyword">if</span> ini - k * num2 &lt; k:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><p>The key insight: if we have <code>k</code> operations and only need <code>count1</code> powers of 2, we can use the extra operations by “splitting” larger powers of 2.</p><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><ul><li><strong>Time Complexity</strong>: O(log(num1)), as we iterate at most log(num1) times</li><li><strong>Space Complexity</strong>: O(1), using only constant extra space</li></ul><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>My iterative approach is essentially equivalent to the mathematical formula:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num1 - k×num2 = 2^i₁ + 2^i₂ + ... + 2^iₖ</span><br></pre></td></tr></table></figure><p>But instead of calculating <code>num1 - k×num2</code> directly, I simulate it step by step:</p><ul><li>Start with <code>k = 1</code></li><li>Subtract <code>num2</code> from <code>num1</code> (simulating one operation)</li><li>Check if the result can be represented with <code>k</code> powers of 2</li><li>If not, increment <code>k</code> and repeat</li></ul><h3 id="Validation-Logic-Explained"><a href="#Validation-Logic-Explained" class="headerlink" title="Validation Logic Explained"></a>Validation Logic Explained</h3><p>The nested conditions in my code serve important purposes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ini &gt; k * num2:  <span class="comment"># Ensure we haven&#x27;t subtracted too much</span></span><br><span class="line">    <span class="keyword">if</span> ini - k * num2 &lt; k:  <span class="comment"># Ensure target &gt;= k (necessary condition)</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><p>This ensures that:</p><ol><li>The total subtraction <code>k * num2</code> doesn’t exceed the original <code>num1</code></li><li>The remaining value <code>ini - k * num2</code> is at least <code>k</code> (since each power of 2 is at least 1)</li></ol><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><p>Let’s trace through some examples using my approach:</p><h3 id="Example-1-num1-11-num2-1"><a href="#Example-1-num1-11-num2-1" class="headerlink" title="Example 1: num1 &#x3D; 11, num2 &#x3D; 1"></a>Example 1: num1 &#x3D; 11, num2 &#x3D; 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Initial: num1 = 11, num2 = 1, ini = 11</span><br><span class="line"></span><br><span class="line">k = 1:</span><br><span class="line">- num1 = 11 - 1 = 10</span><br><span class="line">- bin(10) = &quot;1010&quot;, count = 2</span><br><span class="line">- k (1) &lt; count (2), so increment k</span><br><span class="line"></span><br><span class="line">k = 2:</span><br><span class="line">- num1 = 10 - 1 = 9  </span><br><span class="line">- bin(9) = &quot;1001&quot;, count = 2</span><br><span class="line">- k (2) &gt;= count (2) ✓</span><br><span class="line">- ini (11) &gt; k*num2 (2) ✓</span><br><span class="line">- ini - k*num2 = 9 &gt;= k (2) ✓</span><br><span class="line">- Return 2</span><br></pre></td></tr></table></figure><h3 id="Example-2-num1-5-num2-7"><a href="#Example-2-num1-5-num2-7" class="headerlink" title="Example 2: num1 &#x3D; 5, num2 &#x3D; 7"></a>Example 2: num1 &#x3D; 5, num2 &#x3D; 7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Initial: num1 = 5, num2 = 7</span><br><span class="line"></span><br><span class="line">Early termination: num2 (7) &gt;= num1 (5)</span><br><span class="line">Return -1</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This iterative simulation approach provides a unique perspective on solving LeetCode 2749. While the mathematical modeling approach is more direct, my method offers better intuition about what’s actually happening in each operation.</p><p>The key insight is that we can separate the problem into:</p><ol><li>The <code>num2</code> component (handled by iteration)</li><li>The powers of 2 component (handled by binary analysis)</li></ol><p>This separation makes the solution both understandable and efficient.</p><hr><p><em>Tutorial texts partly co-generated by Claude-4-Sonnet.</em></p><p>Hope this analysis helps you understand my unique approach to LeetCode 2749! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! 🚀</em></p>]]></content>
    
    
    <summary type="html">An O(n) greedy one-pass solution for LeetCode 2749: Minimum Operations to Make Integer Zero.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>The Path of Revelation (啟示路) -- Walk a life, on water and Bewater</title>
    <link href="https://miralemzhang.github.io/2025/09/05/My-First-Blog-Post/"/>
    <id>https://miralemzhang.github.io/2025/09/05/My-First-Blog-Post/</id>
    <published>2025-09-05T09:10:45.000Z</published>
    <updated>2025-10-15T09:42:45.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote style="border: none !important; border-left: none !important; background-color:rgb(36, 39, 43); padding: 10px; margin: 20px 0; border-radius: 8px; color: #ffffff;"><em><span style="font-size: 1.2em; color: #ffffff;">Write the things which thou hast seen, and the things which are, and the things which shall be hereafter.</span></em><br><em style="color: #ffffff;">所以你要把所已看見的事，及以現在的事，並將來必成的事，都記寫出來。</em><div style="text-align: right; margin-top: 10px; font-size: 1em; color: #888;">— Revelation 1:19<br></div></blockquote>]]></content>
    
    
    <summary type="html">所以你要把所已看見的事，及以現在的事，並將來必成的事，都記寫出來。</summary>
    
    
    
    <category term="Thoughts" scheme="https://miralemzhang.github.io/categories/Thoughts/"/>
    
    
    <category term="Book&amp;Music Review" scheme="https://miralemzhang.github.io/tags/Book-Music-Review/"/>
    
  </entry>
  
</feed>
