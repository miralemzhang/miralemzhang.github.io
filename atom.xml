<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MLMZZZOOO&#39;s Blog</title>
  
  <subtitle>discover the world and share my thoughts</subtitle>
  <link href="https://miralemzhang.github.io/atom.xml" rel="self"/>
  
  <link href="https://miralemzhang.github.io/"/>
  <updated>2025-10-15T09:42:00.019Z</updated>
  <id>https://miralemzhang.github.io/</id>
  
  <author>
    <name>Miralem Zhang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode 3350 - Track Adjacent Increasing Subarrays</title>
    <link href="https://miralemzhang.github.io/2025/10/15/LeetCode-3350-One-Pass-Adjacent-Increasing-Subarrays/"/>
    <id>https://miralemzhang.github.io/2025/10/15/LeetCode-3350-One-Pass-Adjacent-Increasing-Subarrays/</id>
    <published>2025-10-14T16:00:00.000Z</published>
    <updated>2025-10-15T09:42:00.019Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/img/lc3350.png"></p><h3 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h3><p>Given an integer array <code>nums</code>, find the maximum length <code>k</code> such that there exist two <strong>adjacent</strong> (non-overlapping) subarrays of length <code>k</code>, and both subarrays are strictly increasing.</p><p>Return the maximum possible value of <code>k</code>. If no such subarrays exist, return <code>1</code>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [2,5,7,8,9,2,3,4,3,1]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The subarrays [2,5,7] and [8,9,2] are not valid.</span><br><span class="line">But [5,7,8] and [9,2,3] are not adjacent.</span><br><span class="line">The valid answer is [2,5,7] (length 3) adjacent to... wait, let me recalculate.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,4,5]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The entire array is strictly increasing with length 5.</span><br><span class="line">We can split it into [1,2] and [3,4], giving us k=2.</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,2,3,2,3,4,3,4,5]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: [1,2,3] and [2,3,4] are adjacent strictly increasing subarrays.</span><br><span class="line">We can pick k=2 from both.</span><br></pre></td></tr></table></figure><hr><h2 id="My-Unique-Approach"><a href="#My-Unique-Approach" class="headerlink" title="My Unique Approach"></a>My Unique Approach</h2><p>Instead of using complex data structures or multiple passes, I developed an <strong>elegant single-pass solution</strong> that tracks consecutive increasing segments and intelligently compares them at boundaries.</p><h3 id="Key-Insight"><a href="#Key-Insight" class="headerlink" title="Key Insight"></a>Key Insight</h3><p>The core idea is to recognize that at any point where an increasing sequence breaks, we have <strong>two opportunities</strong> to maximize <code>k</code>:</p><ol><li><strong>Split Strategy</strong>: Divide the current increasing subarray in half</li><li><strong>Adjacent Strategy</strong>: Pair the previous increasing subarray with the current one</li></ol><p>By tracking both the current and previous subarray lengths, we can evaluate both strategies in <strong>O(1) time</strong> at each boundary.</p><hr><h2 id="Algorithm-Logic"><a href="#Algorithm-Logic" class="headerlink" title="Algorithm Logic"></a>Algorithm Logic</h2><h3 id="The-Tracking-Mechanism"><a href="#The-Tracking-Mechanism" class="headerlink" title="The Tracking Mechanism"></a>The Tracking Mechanism</h3><p>I maintain three critical variables:</p><ul><li><code>count</code>: Length of the current strictly increasing subarray</li><li><code>lastcount</code>: Length of the previous strictly increasing subarray</li><li><code>maxm</code>: The maximum <code>k</code> found so far</li></ul><h3 id="The-Decision-Points"><a href="#The-Decision-Points" class="headerlink" title="The Decision Points"></a>The Decision Points</h3><p>At each position where <code>nums[i] &gt;= nums[i+1]</code> (a break in the increasing sequence), we:</p><ol><li>Compare <code>lastcount</code> and <code>count</code> (adjacent strategy)</li><li>Consider <code>count // 2</code> (split current subarray)</li><li>Update our maximum accordingly</li></ol><h3 id="Edge-Case-Handling"><a href="#Edge-Case-Handling" class="headerlink" title="Edge Case Handling"></a>Edge Case Handling</h3><ul><li><strong>Two-element arrays</strong>: Always return 1</li><li><strong>Fully increasing arrays</strong>: Return <code>len(nums) // 2</code></li><li><strong>Final subarray</strong>: Must be checked after the loop ends</li></ul><hr><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxIncreasingSubarrays</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Edge case: minimum possible input</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        count = <span class="number">1</span>          <span class="comment"># Current increasing subarray length</span></span><br><span class="line">        lastcount = <span class="number">0</span>      <span class="comment"># Previous increasing subarray length</span></span><br><span class="line">        maxm = <span class="number">0</span>           <span class="comment"># Maximum k found</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Single pass through the array</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="comment"># Continue the increasing sequence</span></span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># Break point: evaluate both strategies</span></span><br><span class="line">                <span class="comment"># 1. Adjacent strategy: min(lastcount, count)</span></span><br><span class="line">                <span class="comment"># 2. Split strategy: count // 2</span></span><br><span class="line">                maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(count, lastcount), count // <span class="number">2</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Shift: current becomes previous</span></span><br><span class="line">                lastcount = count</span><br><span class="line">                count = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Don&#x27;t forget the final subarray!</span></span><br><span class="line">        <span class="keyword">if</span> lastcount &gt; <span class="number">0</span>:</span><br><span class="line">            maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lastcount, count), count // <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Special case: entire array is strictly increasing</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> count // <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># If no valid pair found, minimum is always 1</span></span><br><span class="line">        <span class="keyword">return</span> maxm <span class="keyword">if</span> maxm != <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><hr><h2 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h2><p>Let me walk you through each critical part of my solution:</p><h3 id="Step-1-Edge-Case-Two-Elements"><a href="#Step-1-Edge-Case-Two-Elements" class="headerlink" title="Step 1: Edge Case - Two Elements"></a>Step 1: Edge Case - Two Elements</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>For the smallest possible input, we can only have two subarrays of length 1, so return 1 immediately.</p><h3 id="Step-2-The-Core-Loop-Tracking-Increases"><a href="#Step-2-The-Core-Loop-Tracking-Increases" class="headerlink" title="Step 2: The Core Loop - Tracking Increases"></a>Step 2: The Core Loop - Tracking Increases</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; nums[i + <span class="number">1</span>]:</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>As we iterate, we simply count consecutive strictly increasing elements. This gives us the length of the current increasing subarray.</p><h3 id="Step-3-Boundary-Analysis-The-Magic-Happens-Here"><a href="#Step-3-Boundary-Analysis-The-Magic-Happens-Here" class="headerlink" title="Step 3: Boundary Analysis - The Magic Happens Here"></a>Step 3: Boundary Analysis - The Magic Happens Here</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(count, lastcount), count // <span class="number">2</span>)</span><br><span class="line">    lastcount = count</span><br><span class="line">    count = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>When we hit a boundary (increasing sequence breaks), we:</p><ol><li><p><strong>Compare three values</strong>:</p><ul><li>Current maximum: <code>maxm</code></li><li>Adjacent strategy: <code>min(count, lastcount)</code> - take the smaller of the two adjacent subarrays</li><li>Split strategy: <code>count // 2</code> - split the current subarray in half</li></ul></li><li><p><strong>Update tracking</strong>: Move current to previous, reset current to 1</p></li></ol><h3 id="Step-4-Final-Subarray-Check"><a href="#Step-4-Final-Subarray-Check" class="headerlink" title="Step 4: Final Subarray Check"></a>Step 4: Final Subarray Check</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> lastcount &gt; <span class="number">0</span>:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lastcount, count), count // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>After the loop, we still have the final increasing subarray to consider. We must check it against the previous one using the same logic.</p><h3 id="Step-5-Fully-Increasing-Array"><a href="#Step-5-Fully-Increasing-Array" class="headerlink" title="Step 5: Fully Increasing Array"></a>Step 5: Fully Increasing Array</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> count == <span class="built_in">len</span>(nums):</span><br><span class="line">    <span class="keyword">return</span> count // <span class="number">2</span></span><br></pre></td></tr></table></figure><p>If the entire array is strictly increasing (no breaks occurred), the optimal solution is to split it in half.</p><hr><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><h3 id="Time-Complexity-O-n"><a href="#Time-Complexity-O-n" class="headerlink" title="Time Complexity: O(n)"></a>Time Complexity: <strong>O(n)</strong></h3><p>We iterate through the array exactly once, performing constant-time operations at each step:</p><ul><li>Comparison: O(1)</li><li>Counter updates: O(1)</li><li>Max calculations: O(1)</li></ul><p><strong>Total</strong>: Single pass → O(n)</p><h3 id="Space-Complexity-O-1"><a href="#Space-Complexity-O-1" class="headerlink" title="Space Complexity: O(1)"></a>Space Complexity: <strong>O(1)</strong></h3><p>We only use three integer variables regardless of input size:</p><ul><li><code>count</code></li><li><code>lastcount</code></li><li><code>maxm</code></li></ul><p>No additional data structures needed!</p><hr><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>The problem essentially asks: <strong>What’s the maximum k such that we can find two adjacent strictly increasing subarrays of length k?</strong></p><p>My approach recognizes that:</p><ol><li><p><strong>Any strictly increasing subarray of length L can be split into two adjacent subarrays of length L&#x2F;2</strong></p><ul><li>Example: <code>[1,2,3,4]</code> → <code>[1,2]</code> and <code>[3,4]</code></li></ul></li><li><p><strong>Two adjacent strictly increasing subarrays of lengths A and B can form two subarrays of length min(A,B)</strong></p><ul><li>Example: <code>[1,2,3]</code> (length 3) and <code>[5,6]</code> (length 2) → k &#x3D; 2</li></ul></li><li><p><strong>At any boundary, we choose the better strategy</strong></p><ul><li>Split current: <code>count // 2</code></li><li>Use adjacent: <code>min(count, lastcount)</code></li></ul></li></ol><h3 id="The-Greedy-Choice"><a href="#The-Greedy-Choice" class="headerlink" title="The Greedy Choice"></a>The Greedy Choice</h3><p>This solution is <strong>greedy</strong> in nature - at each decision point, we choose the maximum possible value. This works because:</p><ul><li>Once we pass a boundary, the previous subarray length is fixed</li><li>We can’t “go back” and change it</li><li>Therefore, making the locally optimal choice (max of the three options) is globally optimal</li></ul><hr><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><p>Let’s trace through some examples to see the algorithm in action:</p><h3 id="Example-1-nums-2-5-7-8-9-2-3-4-3-1"><a href="#Example-1-nums-2-5-7-8-9-2-3-4-3-1" class="headerlink" title="Example 1: nums &#x3D; [2,5,7,8,9,2,3,4,3,1]"></a>Example 1: nums &#x3D; [2,5,7,8,9,2,3,4,3,1]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 2&lt;5 → count=2</span><br><span class="line">i=1: 5&lt;7 → count=3</span><br><span class="line">i=2: 7&lt;8 → count=4</span><br><span class="line">i=3: 8&lt;9 → count=5</span><br><span class="line">i=4: 9≥2 → Break!</span><br><span class="line">     maxm = max(0, min(5,0), 5//2) = max(0, 0, 2) = 2</span><br><span class="line">     lastcount=5, count=1</span><br><span class="line"></span><br><span class="line">i=5: 2&lt;3 → count=2</span><br><span class="line">i=6: 3&lt;4 → count=3</span><br><span class="line">i=7: 4≥3 → Break!</span><br><span class="line">     maxm = max(2, min(3,5), 3//2) = max(2, 3, 1) = 3</span><br><span class="line">     lastcount=3, count=1</span><br><span class="line"></span><br><span class="line">i=8: 3≥1 → Break!</span><br><span class="line">     maxm = max(3, min(1,3), 1//2) = max(3, 1, 0) = 3</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">Final check:</span><br><span class="line">     maxm = max(3, min(1,1), 1//2) = max(3, 1, 0) = 3</span><br><span class="line"></span><br><span class="line">Output: 3 ✓</span><br></pre></td></tr></table></figure><h3 id="Example-2-nums-1-2-3-4-5"><a href="#Example-2-nums-1-2-3-4-5" class="headerlink" title="Example 2: nums &#x3D; [1,2,3,4,5]"></a>Example 2: nums &#x3D; [1,2,3,4,5]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 1&lt;2 → count=2</span><br><span class="line">i=1: 2&lt;3 → count=3</span><br><span class="line">i=2: 3&lt;4 → count=4</span><br><span class="line">i=3: 4&lt;5 → count=5</span><br><span class="line"></span><br><span class="line">No breaks occurred!</span><br><span class="line"></span><br><span class="line">count == len(nums) → return 5//2 = 2</span><br><span class="line"></span><br><span class="line">Output: 2 ✓</span><br></pre></td></tr></table></figure><h3 id="Example-3-nums-5-4-3-2-1"><a href="#Example-3-nums-5-4-3-2-1" class="headerlink" title="Example 3: nums &#x3D; [5,4,3,2,1]"></a>Example 3: nums &#x3D; [5,4,3,2,1]</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Initial: count=1, lastcount=0, maxm=0</span><br><span class="line"></span><br><span class="line">i=0: 5≥4 → Break!</span><br><span class="line">     maxm = max(0, min(1,0), 1//2) = max(0, 0, 0) = 0</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">i=1: 4≥3 → Break!</span><br><span class="line">     maxm = max(0, min(1,1), 1//2) = max(0, 1, 0) = 1</span><br><span class="line">     lastcount=1, count=1</span><br><span class="line"></span><br><span class="line">... (continues with all breaks)</span><br><span class="line"></span><br><span class="line">Final: maxm = 1</span><br><span class="line"></span><br><span class="line">Output: 1 ✓</span><br></pre></td></tr></table></figure><hr><h2 id="Comparison-with-Alternative-Approaches"><a href="#Comparison-with-Alternative-Approaches" class="headerlink" title="Comparison with Alternative Approaches"></a>Comparison with Alternative Approaches</h2><h3 id="Approach-1-Two-Pass-Solution"><a href="#Approach-1-Two-Pass-Solution" class="headerlink" title="Approach 1: Two-Pass Solution"></a>Approach 1: Two-Pass Solution</h3><p><strong>Idea</strong>: First pass records all increasing subarray lengths, second pass finds maximum k.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># First pass: record lengths</span></span><br><span class="line">lengths = []</span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lengths.append(count)</span><br><span class="line">        count = <span class="number">1</span></span><br><span class="line">lengths.append(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Second pass: find max k</span></span><br><span class="line">maxm = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(lengths)-<span class="number">1</span>):</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, <span class="built_in">min</span>(lengths[i], lengths[i+<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> length <span class="keyword">in</span> lengths:</span><br><span class="line">    maxm = <span class="built_in">max</span>(maxm, length // <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><strong>Drawback</strong>: </p><ul><li>Time: Still O(n) but <strong>two passes</strong></li><li>Space: <strong>O(n)</strong> for the lengths array</li><li>Less elegant code</li></ul><h3 id="Approach-2-Dynamic-Programming"><a href="#Approach-2-Dynamic-Programming" class="headerlink" title="Approach 2: Dynamic Programming"></a>Approach 2: Dynamic Programming</h3><p><strong>Idea</strong>: Track increasing lengths in a DP array.</p><p><strong>Drawback</strong>:</p><ul><li>Overcomplicated for this problem</li><li><strong>O(n) space</strong> required</li><li>No performance benefit</li></ul><h3 id="Why-My-Approach-is-Better"><a href="#Why-My-Approach-is-Better" class="headerlink" title="Why My Approach is Better"></a>Why My Approach is Better</h3><table><thead><tr><th>Metric</th><th>My Solution</th><th>Two-Pass</th><th>DP</th></tr></thead><tbody><tr><td><strong>Time</strong></td><td>O(n) - 1 pass</td><td>O(n) - 2 passes</td><td>O(n)</td></tr><tr><td><strong>Space</strong></td><td><strong>O(1)</strong></td><td>O(n)</td><td>O(n)</td></tr><tr><td><strong>Code Length</strong></td><td>~20 lines</td><td>~30 lines</td><td>~35 lines</td></tr><tr><td><strong>Readability</strong></td><td>⭐⭐⭐⭐⭐</td><td>⭐⭐⭐</td><td>⭐⭐</td></tr></tbody></table><hr><h2 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h2><h3 id="Algorithm-Design-Insights"><a href="#Algorithm-Design-Insights" class="headerlink" title="Algorithm Design Insights"></a>Algorithm Design Insights</h3><ol><li><p><strong>Greedy works when future doesn’t affect past</strong>: Since we’re moving forward and can’t change previous subarrays, greedy choices are safe.</p></li><li><p><strong>Track minimal state</strong>: We only need to remember the previous subarray length, not all previous subarrays.</p></li><li><p><strong>Boundary analysis is powerful</strong>: The break points give us natural decision points.</p></li></ol><h3 id="Coding-Best-Practices"><a href="#Coding-Best-Practices" class="headerlink" title="Coding Best Practices"></a>Coding Best Practices</h3><ol><li><p><strong>Handle edge cases first</strong>: The <code>len(nums)==2</code> check simplifies the main logic.</p></li><li><p><strong>Don’t forget the final element</strong>: After loops, always check if there’s remaining data to process.</p></li><li><p><strong>Use meaningful variable names</strong>: <code>count</code>, <code>lastcount</code>, <code>maxm</code> clearly indicate their purpose.</p></li></ol><hr><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This single-pass tracking solution demonstrates that many problems have elegant solutions when you:</p><ol><li><strong>Identify the key decision points</strong> (boundaries between increasing subarrays)</li><li><strong>Track minimal necessary state</strong> (current and previous lengths)</li><li><strong>Apply greedy logic at each decision point</strong> (maximize k locally)</li></ol><p>The beauty of this approach lies in its simplicity - we achieve optimal time and space complexity with clear, maintainable code.</p><hr><p><em>Tutorial texts partly co-generated by Claude-4-Sonnet.</em></p><p>Hope this detailed walkthrough helps you understand my efficient approach to this problem! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! 🚀</em></p>]]></content>
    
    
    <summary type="html">A one-pass greedy O(n) time O(1) space solution for LeetCode 3350: Maximum Length of Adjacent Increasing Subarrays.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 2749 - Minimum Operations to Make Integer Zero</title>
    <link href="https://miralemzhang.github.io/2025/09/05/LeetCode-2749-Solution-Minimum-Operations-to-Make-Integer-Zero/"/>
    <id>https://miralemzhang.github.io/2025/09/05/LeetCode-2749-Solution-Minimum-Operations-to-Make-Integer-Zero/</id>
    <published>2025-09-05T09:42:09.000Z</published>
    <updated>2025-10-15T09:41:41.643Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><p>You are given two integers <code>num1</code> and <code>num2</code>. In one operation, you can choose integer <code>i</code> and subtract <code>2^i + num2</code> from <code>num1</code>.</p><p>Return the minimum number of operations to make <code>num1</code> equal to <code>0</code>. If it is impossible to make <code>num1</code> equal to <code>0</code>, return <code>-1</code>.</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><strong>Example 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = 3, num2 = -2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: We can apply the following operations:</span><br><span class="line">- Operation 1: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 3 - 2 = 1.</span><br><span class="line">- Operation 2: i = 2, subtract 2^2 + (-2) = 4 - 2 = 2. Now num1 = 1 - 2 = -1.</span><br><span class="line">- Operation 3: i = 0, subtract 2^0 + (-2) = 1 - 2 = -1. Now num1 = -1 - (-1) = 0.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: num1 = 5, num2 = 7</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: It is impossible to make num1 equal to 0.</span><br></pre></td></tr></table></figure><h2 id="My-Unique-Approach"><a href="#My-Unique-Approach" class="headerlink" title="My Unique Approach"></a>My Unique Approach</h2><p>Instead of the traditional mathematical modeling approach, I developed an <strong>iterative simulation method</strong> that directly mimics the operation process:</p><h3 id="Key-Insight"><a href="#Key-Insight" class="headerlink" title="Key Insight"></a>Key Insight</h3><p>The core idea is to simulate the process step by step:</p><ol><li>For each potential number of operations <code>k</code>, subtract <code>num2</code> from <code>num1</code> </li><li>Check if the remaining value can be represented as a sum of exactly <code>k</code> powers of 2</li><li>Use binary representation to count the minimum number of powers of 2 needed</li></ol><h3 id="Algorithm-Logic"><a href="#Algorithm-Logic" class="headerlink" title="Algorithm Logic"></a>Algorithm Logic</h3><ol><li><strong>Early termination</strong>: If <code>num2 &gt;= num1</code>, return -1 (impossible case)</li><li><strong>Iterative checking</strong>: For each <code>k</code> starting from 1:<ul><li>Calculate <code>current = num1 - k * num2</code></li><li>Count the number of 1’s in binary representation of <code>current</code></li><li>If <code>k &gt;= count_of_ones</code>, we can potentially use <code>k</code> operations</li></ul></li><li><strong>Validation</strong>: Ensure the solution is mathematically valid</li></ol><h2 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution"></a>My Solution</h2><h3 id="Python-Implementation"><a href="#Python-Implementation" class="headerlink" title="Python Implementation"></a>Python Implementation</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">makeTheIntegerZero</span>(<span class="params">self, num1, num2</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type num1: int</span></span><br><span class="line"><span class="string">        :type num2: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Early termination: if num2 &gt;= num1, impossible to reach 0</span></span><br><span class="line">        <span class="keyword">if</span> num2 &gt;= num1:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = <span class="number">1</span></span><br><span class="line">            ini = num1  <span class="comment"># Store original num1 for validation</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="comment"># Simulate subtracting num2 for k operations</span></span><br><span class="line">                num1 -= num2</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Convert to binary and count 1&#x27;s</span></span><br><span class="line">                bin1 = <span class="built_in">bin</span>(num1)[<span class="number">2</span>:]</span><br><span class="line">                count1 = bin1.count(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># Check if we can use k operations</span></span><br><span class="line">                <span class="keyword">if</span> k &gt;= count1:</span><br><span class="line">                    <span class="comment"># Validation checks</span></span><br><span class="line">                    <span class="keyword">if</span> ini &gt; k * num2:</span><br><span class="line">                        <span class="keyword">if</span> ini - k * num2 &lt; k:</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                        <span class="keyword">return</span> k</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># Need more operations</span></span><br><span class="line">                    k += <span class="number">1</span></span><br><span class="line">                    bin1 = <span class="number">0</span></span><br><span class="line">                    count1 = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="Algorithm-Breakdown"><a href="#Algorithm-Breakdown" class="headerlink" title="Algorithm Breakdown"></a>Algorithm Breakdown</h3><p>Let me explain each part of my unique approach:</p><h4 id="Step-1-Early-Termination"><a href="#Step-1-Early-Termination" class="headerlink" title="Step 1: Early Termination"></a>Step 1: Early Termination</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> num2 &gt;= num1:</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>If <code>num2</code> is greater than or equal to <code>num1</code>, it’s impossible to make <code>num1</code> zero because each operation adds at least <code>num2</code> to the subtraction.</p><h4 id="Step-2-Iterative-Simulation"><a href="#Step-2-Iterative-Simulation" class="headerlink" title="Step 2: Iterative Simulation"></a>Step 2: Iterative Simulation</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">k = <span class="number">1</span></span><br><span class="line">ini = num1  <span class="comment"># Store original value</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num1 -= num2  <span class="comment"># Simulate the num2 part of each operation</span></span><br></pre></td></tr></table></figure><p>Instead of calculating <code>target = num1 - k * num2</code> directly, I simulate the process by subtracting <code>num2</code> in each iteration.</p><h4 id="Step-3-Binary-Analysis"><a href="#Step-3-Binary-Analysis" class="headerlink" title="Step 3: Binary Analysis"></a>Step 3: Binary Analysis</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin1 = <span class="built_in">bin</span>(num1)[<span class="number">2</span>:]</span><br><span class="line">count1 = bin1.count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure><p>For the current value, count how many 1’s are in its binary representation. This tells us the minimum number of powers of 2 needed.</p><h4 id="Step-4-Feasibility-Check"><a href="#Step-4-Feasibility-Check" class="headerlink" title="Step 4: Feasibility Check"></a>Step 4: Feasibility Check</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k &gt;= count1:</span><br><span class="line">    <span class="comment"># We have enough operations to represent the number</span></span><br><span class="line">    <span class="keyword">if</span> ini &gt; k * num2:</span><br><span class="line">        <span class="keyword">if</span> ini - k * num2 &lt; k:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><p>The key insight: if we have <code>k</code> operations and only need <code>count1</code> powers of 2, we can use the extra operations by “splitting” larger powers of 2.</p><h2 id="Complexity-Analysis"><a href="#Complexity-Analysis" class="headerlink" title="Complexity Analysis"></a>Complexity Analysis</h2><ul><li><strong>Time Complexity</strong>: O(log(num1)), as we iterate at most log(num1) times</li><li><strong>Space Complexity</strong>: O(1), using only constant extra space</li></ul><h2 id="Why-This-Approach-Works"><a href="#Why-This-Approach-Works" class="headerlink" title="Why This Approach Works"></a>Why This Approach Works</h2><h3 id="The-Mathematical-Foundation"><a href="#The-Mathematical-Foundation" class="headerlink" title="The Mathematical Foundation"></a>The Mathematical Foundation</h3><p>My iterative approach is essentially equivalent to the mathematical formula:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num1 - k×num2 = 2^i₁ + 2^i₂ + ... + 2^iₖ</span><br></pre></td></tr></table></figure><p>But instead of calculating <code>num1 - k×num2</code> directly, I simulate it step by step:</p><ul><li>Start with <code>k = 1</code></li><li>Subtract <code>num2</code> from <code>num1</code> (simulating one operation)</li><li>Check if the result can be represented with <code>k</code> powers of 2</li><li>If not, increment <code>k</code> and repeat</li></ul><h3 id="Validation-Logic-Explained"><a href="#Validation-Logic-Explained" class="headerlink" title="Validation Logic Explained"></a>Validation Logic Explained</h3><p>The nested conditions in my code serve important purposes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ini &gt; k * num2:  <span class="comment"># Ensure we haven&#x27;t subtracted too much</span></span><br><span class="line">    <span class="keyword">if</span> ini - k * num2 &lt; k:  <span class="comment"># Ensure target &gt;= k (necessary condition)</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><p>This ensures that:</p><ol><li>The total subtraction <code>k * num2</code> doesn’t exceed the original <code>num1</code></li><li>The remaining value <code>ini - k * num2</code> is at least <code>k</code> (since each power of 2 is at least 1)</li></ol><h2 id="Test-Cases-Walkthrough"><a href="#Test-Cases-Walkthrough" class="headerlink" title="Test Cases Walkthrough"></a>Test Cases Walkthrough</h2><p>Let’s trace through some examples using my approach:</p><h3 id="Example-1-num1-11-num2-1"><a href="#Example-1-num1-11-num2-1" class="headerlink" title="Example 1: num1 &#x3D; 11, num2 &#x3D; 1"></a>Example 1: num1 &#x3D; 11, num2 &#x3D; 1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Initial: num1 = 11, num2 = 1, ini = 11</span><br><span class="line"></span><br><span class="line">k = 1:</span><br><span class="line">- num1 = 11 - 1 = 10</span><br><span class="line">- bin(10) = &quot;1010&quot;, count = 2</span><br><span class="line">- k (1) &lt; count (2), so increment k</span><br><span class="line"></span><br><span class="line">k = 2:</span><br><span class="line">- num1 = 10 - 1 = 9  </span><br><span class="line">- bin(9) = &quot;1001&quot;, count = 2</span><br><span class="line">- k (2) &gt;= count (2) ✓</span><br><span class="line">- ini (11) &gt; k*num2 (2) ✓</span><br><span class="line">- ini - k*num2 = 9 &gt;= k (2) ✓</span><br><span class="line">- Return 2</span><br></pre></td></tr></table></figure><h3 id="Example-2-num1-5-num2-7"><a href="#Example-2-num1-5-num2-7" class="headerlink" title="Example 2: num1 &#x3D; 5, num2 &#x3D; 7"></a>Example 2: num1 &#x3D; 5, num2 &#x3D; 7</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Initial: num1 = 5, num2 = 7</span><br><span class="line"></span><br><span class="line">Early termination: num2 (7) &gt;= num1 (5)</span><br><span class="line">Return -1</span><br></pre></td></tr></table></figure><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This iterative simulation approach provides a unique perspective on solving LeetCode 2749. While the mathematical modeling approach is more direct, my method offers better intuition about what’s actually happening in each operation.</p><p>The key insight is that we can separate the problem into:</p><ol><li>The <code>num2</code> component (handled by iteration)</li><li>The powers of 2 component (handled by binary analysis)</li></ol><p>This separation makes the solution both understandable and efficient.</p><hr><p><em>Tutorial texts partly co-generated by Claude-4-Sonnet.</em></p><p>Hope this analysis helps you understand my unique approach to LeetCode 2749! Feel free to discuss any questions in the comments.</p><p><em>Happy Coding! 🚀</em></p>]]></content>
    
    
    <summary type="html">An O(n) greedy one-pass solution for LeetCode 2749: Minimum Operations to Make Integer Zero.</summary>
    
    
    
    <category term="Coding" scheme="https://miralemzhang.github.io/categories/Coding/"/>
    
    
    <category term="LeetCode" scheme="https://miralemzhang.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>The Path of Revelation (啟示路) -- Walk a life, on water and Bewater</title>
    <link href="https://miralemzhang.github.io/2025/09/05/My-First-Blog-Post/"/>
    <id>https://miralemzhang.github.io/2025/09/05/My-First-Blog-Post/</id>
    <published>2025-09-05T09:10:45.000Z</published>
    <updated>2025-10-15T09:42:45.508Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote style="border: none !important; border-left: none !important; background-color:rgb(36, 39, 43); padding: 10px; margin: 20px 0; border-radius: 8px; color: #ffffff;"><em><span style="font-size: 1.2em; color: #ffffff;">Write the things which thou hast seen, and the things which are, and the things which shall be hereafter.</span></em><br><em style="color: #ffffff;">所以你要把所已看見的事，及以現在的事，並將來必成的事，都記寫出來。</em><div style="text-align: right; margin-top: 10px; font-size: 1em; color: #888;">— Revelation 1:19<br></div></blockquote>]]></content>
    
    
    <summary type="html">所以你要把所已看見的事，及以現在的事，並將來必成的事，都記寫出來。</summary>
    
    
    
    <category term="Thoughts" scheme="https://miralemzhang.github.io/categories/Thoughts/"/>
    
    
    <category term="Book&amp;Music Review" scheme="https://miralemzhang.github.io/tags/Book-Music-Review/"/>
    
  </entry>
  
</feed>
